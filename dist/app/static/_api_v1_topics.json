{
  "success": true,
  "data": [
    {
      "id": "5b6913d858db3ccf66a452c9",
      "author_id": "5b691298b71aedfe4c1267e0",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>阿里云MVP(Most Valuable Professional，最有价值专家)第六期全球招募开始了! 面向全球开发者，寻找热爱技术、乐于分享的Coder！</p>\n<p><strong>什么是阿里云 MVP？</strong>  阿里云MVP(Most Valuable Professional，最有价值专家)，是专注于帮助他人充分了解和使用阿里云产品和服务的技术实践领袖。截止到2018年6月已经有232位全球各国家和地区的Coder们参加了5期认证。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fp3m6H3ivwP65mX8b1zvzHQZz4Ig\" alt=\"image.png\"></p>\n<p>只要成为MVP，即可享受免费云栖大会门票、最新产品的优先使用权、官方渠道推广等丰厚权益。升级后，还有全球技术留学、高端闭门会议，与顶级技术专家交流学习。与您一同打造《MVP 时间》将您的技术能量传播给更多人，定期邀请阿里技术专家在MVP学院与您共同交流学习提升技术实力。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNR6aaofpaIpJit_sOxtLMPjgMe\" alt=\"image.png\"></p>\n<p>本期MVP项目与本社区合作推荐技术达人成为侯选人，通过认证您还可以在9月到杭州参与一年一度的MVP高端闭门峰会，第6期认证结果将在9月中旬公布结果。</p>\n<p><strong>什么样的人可以成为阿里云 MVP？</strong>\n你交叉使用过阿里云多款产品；\n你有丰富的技术沉淀、勇于创新、乐于分享；\n你希望能寻找志同道合的资深技术圈，希望建立个人技术影响力。</p>\n<p>你可以马上点击本社区专属申请链接提交申请或扫码填写申请：\n<a href=\"https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==\">https://mvp.aliyun.com/mvp/apply?recommendType=2&amp;recommendId=LjJNaiBNwbNGUe8RWFb9+A==</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Ft1ylAlk9SWi9QcmyzUo5N2-QHTj\" alt=\"image.png\"></p>\n<p><strong>对于阿里云 MVP申请的一些疑问：</strong></p>\n<p><strong>多久评选一次MVP？</strong>\n每个季度会评选一次，并会在每个季度末宣布MVP入围情况，如果遗憾落选，可在公布名单后，重新到MVP平台提交申请。</p>\n<p><strong>MVP代表阿里云吗？</strong>\n不代表。MVP不是阿里巴巴的员工，他们也不代表阿里云发言。MVP仅是因其在技术社区中的杰出成就，而获得阿里云认可和奖励的第三方个人。</p>\n<p><strong>阿里云MVP大奖的有效期为多长时间？</strong>\nMVP大奖的有效期为一年。在此期间，MVP奖获奖者享有阿里云MVP荣誉称号以及大奖所包括的所有特权。</p>\n</div>",
      "title": "阿里云 MVP第6期招募与社区合作启动",
      "last_reply_at": "2018-08-31T09:59:00.524Z",
      "good": false,
      "top": true,
      "reply_count": 8,
      "visit_count": 3000,
      "create_at": "2018-08-07T03:36:56.821Z",
      "author": {
        "loginname": "bian17888",
        "avatar_url": "https://avatars3.githubusercontent.com/u/3838445?v=4&s=120"
      }
    },
    {
      "id": "5b5f231f58db3ccf66a45083",
      "author_id": "509ba2ca637ffa41555c0c56",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>会议现场视频</h1>\n<p><a href=\"http://list.youku.com/albumlist/show/id_51860084\">http://list.youku.com/albumlist/show/id_51860084</a></p>\n<p>不仅仅只是 MVC。</p>\n<p>数据复杂，依赖众多，事务密集，业务多变 …</p>\n<p>都说: 一入企业深似海。</p>\n<p>「现象级」的新潮服务端编程语言 Node.js 进入企业级应用开发领域，</p>\n<p>实践与得失值得被分享，讨论，复盘，才会迎来真正的成熟。</p>\n<p>Node.js 地下铁第六期，这个8月，成都，我们和 5 位 Node.js 分享嘉宾，诚邀富有 Node.js 企业级应用开发和架构经验的你一起现场讨论「企业级的 Node.js 实践」。</p>\n<h3>交流会已结束，交流会总结以及分享 slide 下载以及视频请移步 --&gt; <a href=\"https://mp.weixin.qq.com/s?__biz=MzI0MzA3MDQ2OA==&amp;mid=2660173297&amp;idx=1&amp;sn=b1af9764dadd497752d6ce13c7aefe52&amp;chksm=f209069ac57e8f8c869e7e1d7a6ce7931ab859b10b4c54331295ca8c1235a9ee230fceb3f26d&amp;token=207116455&amp;lang=zh_CN#rd\">微信链接</a></h3>\n<h3>时间: 2018. 08. 11</h3>\n<h3>地点: 蚂蚁 C 空间</h3>\n<h3>报名链接: <a href=\"https://survey.alibaba.com/survey/AwDDMHQ-C\">https://survey.alibaba.com/survey/AwDDMHQ-C</a></h3>\n<p>沙龙场地有限，在报名链接中仔细填写「关注企业级的Node.js实践中的哪些具体问题」对最终挑选参加资格会有帮助。</p>\n<h3>Agenda</h3>\n<p><strong>Node.js 微服务架构之路</strong> by 秦粤@阿里巴巴国际</p>\n<blockquote>\n<p>微服务架构组成的要素，如何通过 DDD(Domain Drive Design) 去切分巨石应用；巨石应用平滑演进到微服务；使用 Egg.js + Dubbo 落地 Node.js 的微服务。</p>\n</blockquote>\n<p><strong>企业级的 Node.js 安全保障</strong> by 林晨<a href=\"/user/thoughtworks\">@thoughtworks</a></p>\n<blockquote>\n<p>企业级别的应用需要有企业级别的安全保障，NSP(Node.js Security Platform) 于今年4月被 npm 收购，成为 npm 的重要拼图。分享 NSP 是什么，能解决什么问题，企业如何通过 NSP 来保障应用安全不会被三方依赖的漏洞所影响的最佳实践。</p>\n</blockquote>\n<p><strong>构建一套全栈应用开发模型</strong> by 张挺@淘宝</p>\n<blockquote>\n<p>随着越来越多的 Node.js 应用在阿里体系中萌芽，承载巨大流量的企业级全栈应用也在不断地考验开发者的能力。这些应用的稳定性，扩展性，可维护性，对于前端来说是一个巨大的考验，淘宝在这一方面进行了多年的全栈尝试，这一次，我们在 Midway 框架中，使用了 Typescript 以及依赖注入，给应用带来截然不同的变化。</p>\n</blockquote>\n<p><strong>如何实现一个 Node.js RPC</strong> by 宗羽@蚂蚁金服</p>\n<blockquote>\n<p>Node.js 如何在阿里、蚂蚁这样的公司生存下来？首要解决的是和现有基础设施打通的问题，而 RPC 又是其中最常用的一个基础设施。经过四五年的发展，我们在这块积累了丰富的经验并且经受过多次双 11 级别的考验，可以说已经形成了成熟、可靠、高性能的 Nodejs RPC 方案。我会尝试从零开始介绍一个 RPC 框架的实现原理，包括协议部分、服务寻址、负载均衡等话题。</p>\n</blockquote>\n<p><strong>Stream 企业级实战</strong> by seth@数蚁科技</p>\n<blockquote>\n<p>从基础的 Node.js 处理 stream/buffer 讲起，逐步深入到 Stream 的企业应用实践，比如如何做 part stream，如何做流的限速，如何做的流的加密。</p>\n</blockquote>\n<p><strong>圆桌交流: 企业级的 Node.js 实践</strong></p>\n<p>本次沙龙合作伙伴: ThoughtWorks Community</p>\n<h1>会议现场视频</h1>\n<p><a href=\"http://list.youku.com/albumlist/show/id_51860084\">http://list.youku.com/albumlist/show/id_51860084</a></p>\n</div>",
      "title": "【视频分享】Node 地下铁第六期「成都站」- 企业级的 Node.js 实践",
      "last_reply_at": "2018-08-31T08:43:20.150Z",
      "good": false,
      "top": true,
      "reply_count": 40,
      "visit_count": 5149,
      "create_at": "2018-07-30T14:39:27.127Z",
      "author": {
        "loginname": "wuminqi",
        "avatar_url": "https://avatars1.githubusercontent.com/u/628250?v=4&s=120"
      }
    },
    {
      "id": "5b223c1d5cd02be640901490",
      "author_id": "515005e9604b3d512109bb17",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FggqZHIE8va72-RguIC8WKGgyzVn\" alt=\"封面\"></p>\n<blockquote>\n<p>千呼万唤始出来，犹抱琵琶生哪吒。</p>\n<p>真的不好意思自卖自夸，所以索性直接把编辑推荐语、大佬们的评语贴上来好了。</p>\n</blockquote>\n<p>Node.js 作为近几年新兴的一种编程运行时，托 V8 引擎的福，在作为后端服务时有比较高的运行效率，在很多场景下对于我们的日常开发足够用了。不过，它还为开发者开了一个使用C++ 开发 Node.js 原生扩展的口子，让开发者进行项目开发时有了更多的选择。</p>\n<p>《Node.js：来一打 C++ 扩展》以 Chrome V8 的知识作为基础，配合 GYP 的一些内容，将教会大家如何使用 Node.js提供的一些 API 来编写其 C++ 的原生扩展。此外，在后续的进阶章节中，还会介绍原生抽象NAN 以及与异步相关的 libuv 知识，最后辅以几个实例来加深理解。不过，在学习本书内容之前，希望读者已经具备了初步的 Node.js 以及 C++ 基础。</p>\n<p>阅读《Node.js：来一打 C++ 扩展》，相当于同时学习Chrome V8 开发、libuv 开发以及 Node.js 的原生 C++ 扩展开发知识，非常值得！</p>\n<p><strong>最后十分感谢包括 Node.js TSC 之一的 Anna、几位 Collaborator 以及各位业界的大佬帮忙写推荐语，感谢 <a href=\"/user/yorkie\">@yorkie</a> 大佬和 <a href=\"/user/justjavac\">@justjavac</a> 大佬帮忙作序。</strong></p>\n<h2>编辑推荐</h2>\n<p>《Node.js：来一打 C++ 扩展》在深度上远远超过了目前市面上的Node书籍。全书自始至终围绕一个主题展开：从介绍 Node.js 的包和模块规范开始，深入解析（包括但不限于剖析 Node.js 自身的源码） Node.js 的模块是如何在运行时被引入的，尤其是如何引入 C++ 模块的；接下来详细讲解了在什么时候、为何要编写 C++ 模块；借此契机，深入介绍了 Node.js 的基石 Chrome V8 和 libuv，以及异步非阻塞的原理——不仅如此，本书更教你如何在底层去驾驭它们。所以，本书以 Node.js 的 C++ 扩展为中心，衍生出对 Node.js 底层风光的层层剖析，最后再回归到如何编写 Node.js 的 C++ 扩展，一气呵成。读来酣畅淋漓，痛快不已！</p>\n<p>买这一本书相当于买了“Node.js 的底层风光、C++ 扩展编写”、“Chrome V8”和“libuv”三本书！</p>\n<p>读完本书后，你甚至能为 Node.js 自身的添砖加瓦做出非凡贡献。</p>\n<h2>购书链接</h2>\n<p><strong>目前在预售阶段，顺便蹭 618 活动。</strong></p>\n<ul>\n<li><a href=\"https://item.jd.com/12380404.html\">京东</a></li>\n<li><a href=\"https://detail.tmall.com/item.htm?id=571628730908&amp;cat_id=2\">天猫</a></li>\n<li><a href=\"http://product.dangdang.com/25291814.html\">当当</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07DL8GHQC/ie=UTF8&amp;qid=1528969734\">亚马逊</a></li>\n<li><a href=\"http://product.china-pub.com/8039217\">china-pub</a></li>\n<li><a href=\"https://book.douban.com/subject/30247892/\">豆瓣</a>（不算购书链接）</li>\n</ul>\n<h2>目录</h2>\n<pre class=\"prettyprint\"><code>1 Node.js 的 C++ 扩展前驱知识储备 1\n1.1 Node.js 的模块机制 2\n1.1.1 CommonJS 的模块规范 2\n1.1.2 Node.js 的模块 4\n1.1.3 小结 9\n1.1.4 参考资料 9\n1.2 Node.js 的包机制 9\n1.2.1 CommonJS 的包规范 9\n1.2.2 Node.js &#x2F; NPM 下的包 13\n1.2.3 NPM 与 CNPM 16\n1.2.4 小结 19\n1.2.5 参考资料 19\n1.3 Node.js 依赖简介 20\n1.3.1 Chrome V8 20\n1.3.2 libuv 25\n1.3.3 其他依赖 28\n1.3.4 小结 30\n1.3.5 参考资料 30\n1.4 C++ 扩展开发的准备工作 31\n1.4.1 编辑器 &#x2F; IDE 31\n1.4.2 node-gyp 36\n1.4.3 其他构建工具 54\n1.4.4 小结 56\n1.4.5 参考资料 56\n2 C++ 模块原理简析 57\n2.1 为什么要写 C++ 模块 57\n2.1.1 C++ 比 JavaScript 解释器高效 57\n2.1.2 已有的 C++ 轮子 72\n2.1.3 小结 77\n2.1.4 参考资料 77\n2.2 什么是 C++ 扩展 78\n2.2.1 C++ 模块本质 78\n2.2.2 Node.js 模块加载原理 80\n2.2.3 小结 102\n2.2.4 参考资料 103\n3 Chrome V8 基础 104\n3.1 Node.js 与 Chrome V8 104\n3.2 基本概念 105\n3.2.1 内存机制 105\n3.2.2 隔离实例（Isolate） 108\n3.2.3 上下文（Context） 109\n3.2.4 脚本（Script） 110\n3.2.5 小结 110\n3.2.6 参考资料 111\n3.3 句柄（Handle） 111\n3.3.1 本地句柄（Local） 112\n3.3.2 持久句柄（Persistent） 115\n3.3.3 永生句柄（Eternal） 119\n3.3.4 待实本地句柄（Maybe Local） 119\n3.3.5 小结 121\n3.3.6 参考资料 121\n3.4 句柄作用域 121\n3.4.1 一般句柄作用域（Handle Scope） 122\n3.4.2 可逃句柄作用域（Escapable Handle Scope） 125\n3.4.3 小结 129\n3.4.4 参考资料 129\n3.5 上下文（Context） 129\n3.6 模板（Template） 133\n3.6.1 函数模板（Function Template） 133\n3.6.2 对象模板（Object Template） 138\n3.6.3 对象模板的访问器（Accessor）与拦截器（Interceptor） 144\n3.6.4 对象模板的内置字段（Internal Field） 175\n3.6.5 函数模板的继承（Inherit） 183\n3.6.6 小结 188\n3.6.7 参考资料 189\n3.7 常用数据类型 189\n3.7.1 基值（Value） 189\n3.7.2 字符串（String） 194\n3.7.3 数值类型 196\n3.7.4 布尔类型（Boolean） 196\n3.7.5 对象（Object） 196\n3.7.6 函数（Function） 200\n3.7.7 数组（Array） 202\n3.7.8 JSON 解析器 203\n3.7.9 函数回调信息（Function Callback Info） 203\n3.7.10 函数返回值（Return Value） 204\n3.7.11 隔离实例（Isolate） 204\n3.7.12 小结 205\n3.7.13 参考资料 206\n3.8 异常机制 206\n3.8.1 try-catch 206\n3.8.2 抛出异常 209\n3.8.3 异常生成类（Exception） 211\n3.8.4 小结 211\n3.8.5 参考资料 211\n4 C++ 扩展实战初探 212\n4.1 binding.gyp 212\n4.1.1 惊鸿一瞥 213\n4.1.2 binding.gyp 基础结构 213\n4.1.3 GYP 文件 214\n4.1.4 常用字段 221\n4.1.5 小结 228\n4.1.6 参考资料 228\n4.2 牛刀小试 229\n4.2.1 又是 Hello World 229\n4.2.2 函数参数 232\n4.2.3 回调函数 234\n4.2.4 函数返回 238\n4.2.5 小结 239\n4.2.6 参考资料 240\n4.3 循序渐进 240\n4.3.1 C++ 与 JavaScript 类封装 240\n4.3.2 实例化 C++ 类封装对象的函数 250\n4.3.3 将 C++ 类封装对象传来传去 253\n4.3.4 进程退出钩子 255\n4.3.5 小结 259\n4.3.6 参考资料 259\n5 Node.js 原生抽象——NAN 260\n5.1 Node.js 原生模块开发方式的变迁 260\n5.1.1 以不变应万变 260\n5.1.2 时代在召唤 261\n5.1.3 小结 267\n5.1.4 参考资料 267\n5.2 基础开发 267\n5.2.1 什么是 NAN 267\n5.2.2 安装和配置 269\n5.2.3 先睹为快——搭上NAN 的快车 270\n5.2.4 基础帮助函数和宏 276\n5.2.5 忽略 node_modules 279\n5.2.6 小结 279\n5.2.7 参考资料 280\n5.3 JavaScript 函数 280\n5.3.1 函数参数类型 280\n5.3.2 函数声明 282\n5.3.3 函数设置 288\n5.3.4 小结 296\n5.3.5 参考资料 296\n5.4 常用帮助类与函数 296\n5.4.1 句柄相关 296\n5.4.2 创建数据对象 298\n5.4.3 与数据对象“玩耍” 300\n5.4.4 封装一个类 314\n5.4.5 异常处理 315\n5.4.6 小结 315\n5.4.7 参考资料 316\n5.5 NAN 中的异步机制 316\n5.5.1 Nan::AsyncQueueWorker 316\n5.5.2 Nan::Callback 317\n5.5.3 Nan::AsyncWorker 317\n5.5.4 Nan::AsyncProgressWorker 323\n5.5.5 小结 327\n5.5.6 参考资料 327\n6 异步之旅——libuv 328\n6.1 基础概念 329\n6.1.1 事件循环 330\n6.1.2 句柄（Handle）与请求（Request） 333\n6.1.3 尝尝甜头 335\n6.1.4 小结 340\n6.1.5 参考资料 340\n6.2 libuv 的跨线程编程基础 341\n6.2.1 libuv 的线程 342\n6.2.2 同步原语（Synchronization Primitive） 347\n6.2.3 工作队列 355\n6.2.4 小结 356\n6.2.5 参考资料 357\n6.3 跨线程通信 357\n6.3.1 uv_async_t 句柄 357\n6.3.2 Watchdog 半成品实战解析 358\n6.3.3 Watchdog 试运行 367\n6.3.4 小结 368\n6.3.5 参考资料 369\n7 实战——文件监视器 370\n7.1 准备工作 370\n7.1.1 功能规划 370\n7.1.2 文件系统监听库——efsw 373\n7.1.3 小结 376\n7.1.4 参考资料 376\n7.2 核心设计 376\n7.2.1 API 设计 377\n7.2.2 EFSWCore 的血肉之躯 377\n7.2.3 EFSWCore 的灵魂 381\n7.2.4 小结 385\n7.3 编写JavaScript 类 386\n7.3.1 类的设计 386\n7.3.2 核心逻辑 388\n7.3.3 简单容错 391\n7.3.4 小结 393\n7.4 进一步完善 393\n7.4.1 C++ 代码的完善 393\n7.4.2 JavaScript 代码的完善 398\n7.4.3 小结 400\n8 实战——现有包剖析 401\n8.1 字符串哈希模块——Bling Hashes 401\n8.1.1 文件设定 402\n8.1.2 C++ 源码剖析 403\n8.1.3 JavaScript 源码剖析 408\n8.1.4 小结 409\n8.1.5 参考资料 410\n8.2 类 Proxy 包——Auto Object 410\n8.2.1 Proxy 410\n8.2.2 Auto Object 使用范例 412\n8.2.3 代码剖析 415\n8.2.4 小结 424\n8.2.5 参考资料 424\n9 N-API——下一代 Node.js C++ 扩展开发方式 425\n9.1 浅尝辄止 426\n9.1.1 实现一个 Echo 函数 426\n9.1.2 尝试运行 N-API 扩展 430\n9.1.3 向下兼容 431\n9.1.4 N-API Package——C++ 封装 433\n9.1.5 小结 433\n9.1.6 参考资料 433\n9.2 基本数据类型与错误处理 433\n9.2.1 基本数据类型 433\n9.2.2 与作用域及生命周期相关的数据类型 435\n9.2.3 回调数据类型 438\n9.2.4 错误处理 439\n9.2.5 模块注册 441\n9.2.6 小结 442\n9.2.7 参考资料 442\n9.3 对象与函数 442\n9.3.1 对象 442\n9.3.2 函数 448\n9.3.3 类的封装 453\n9.3.4 小结 455\n9.3.5 参考资料 455\n</code></pre><h2>推荐语</h2>\n<blockquote>\n<p>This book contains absolutely everything you need to know about how all the pieces of Node.js’ C++ code work and interact, explaining the necessary concepts without needing prior knowledge about the internals of V8, libuv or other pieces of Node.js. It shows well how Node.js’ own built-in modules are constructed using the APIs provided by V8, so that they are usable from JavaScript, and how you can create the same kind of modules from scratch.</p>\n<p>After having read this book, you will be able to write a production-quality, future-proof C++ extension for Node.js if you need to do that, or maybe even make changes Node.js itself if you’re interested in that!</p>\n<p>这本书包含了所有你需要了解的有关于 Node.js C++ 代码是如何运行和交互的知识，解释了一些你不需要知道 V8 的内部机制就能理解的必要概念，另外该书还介绍了 libuv 以及其他一些内容的方方面面。这本书还展示了 Node.js 的内置模块是如何使用 V8 的 API 进行构建并在 JavaScript 层面能提供使用的——并且你也能用这种方法从头开始创建相同类型的模块。</p>\n<p>读完这本书，你将学到如何写出产品级质量的、面向未来的 Node.js C++ 扩展。感兴趣的话，你甚至可以对 Node.js 自身进行修改！</p>\n<p>——安娜·亨宁森（Anna Henningsen, addaleax），Node.js 技术指导委员会成员（Node.js TSC）</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Node.js 不是第一个将 JavaScript 带入服务器端领域的技术，然而却成为了史上最热门、最有影响力的工具之一。究其原因，其一，在于 Node.js 适逢后端高并发潮流，巧妙结合 Reactor 模型和 JavaScript 所擅长的回调风格，大大降低了开发高并发服务器应用的成本；其二，在于恰逢浏览器大战，前端技术突飞猛进，急需一个适合 JavaScript 和前端工程师的一套生态和工具链，Node.js 刚好成为前端 JavaScript 最易上手掌握的命令行环境。在 Node.js 发展这么火热之后，Node.js 的开发体验在不断提升，上手门槛也在不断降低。</p>\n<p>然而，如果大家真正想突破自己成为个中高手，无论是后端程序员希望在服务器端及架构方面有所建树，还是前端程序员想跨越边界，你们都应该去了解 Node.js 的底层机制，去学习写一些 Node.js 的扩展。从 Node.js 的内在机制，我们可以学习到更多有关计算机体系的知识如内存管理、多线程编程等等，真正向一个架构师、大牛迈进。</p>\n<p>死月的书，给我们在这些方面带来了一个非常系统的指南。死月通过精彩的内容告诉大家：底层的知识并不枯燥，用 C++ 写一个扩展很有意思也很简单。作为 Node.js 工程师/爱好者的你，值得拥有本书。</p>\n<p>——曹力（ShiningRay），酷链科技 CEO，前暴走漫画 CTO，前糗事百科联合创始人，高级 Node.js 技术专家，《JavaScript 高级程序设计》译者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>Native module is one of the most underappreciated features of Node.js. But even in the age of asm.js and WebAssembly, it is an irreplaceable part of the Node.js ecosystem due to its versatility and performance. XadillaX’s book provides a refreshing introduction (or reintroduction), and is a must-read for all low-level Node.js engineers.</p>\n<p>原生模块是 Node.js 中最被低估的功能之一。因为它的性能和多样性，使其即使是在 asm.js 和 WebAssembly 时代，仍旧能作为 Node.js 生态系统中不可替代的部分存在。死月的书对其作了一个令人耳目一新的介绍，是所有的底层（Low-Level）Node.js 工程师必读之物。</p>\n<p>——顾天骋（Timothy Gu），pug、ejs 前 Maintainer，Node.js Core Collaborator 之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>本书全面讲解了 V8、libuv 的原理并且手把手教你编写一打 Node.js 的 C++ 扩展，是目前市面上相关领域非常空缺的技术书籍。如果想更深入了解 Node.js 的实现原理，除了熟读内置 API 文档之外，阅读这本书会是一个很好的选择。</p>\n<p>——雷宗民（老雷），《Node.js 实战》作者之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>这是一本角度刁钻的 Node.js 相关书籍，与市面上大多数的 Node.js 书籍定位不同。它借为 Node.js 开发 C++ 扩展为基石，顺带介绍了 Chrome V8 和 libuv 的内容，填补了市场上这一类书籍的空白，值得一读。</p>\n<p>——李启雷博士，趣链科技 CTO</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月一直把实战贯穿在整本书之内，无论是基础部分的 V8 练习，还是使用 Node.js 经典的 Addon 开发、用 NAN 来改写，或是 libuv 里的 WatchDog 案例、EFSW 的封装，甚至在第八章里还特意剖析了两个 C++ 模块，把之前讲解的基础知识部分综合起来，可以边学边练。</p>\n<p>这本《Node.js：来一打 C++ 扩展》，在如今追求大而全的时代，单纯的讲 Node.js 的某一个方面，而且讲的特别棒的书，真的难得。</p>\n<p>——刘琥（响马），西祠胡同创始人，fibjs 作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>当你掌握了 Node.js 的上层使用，下一步进阶的方向就是研究 Node.js 的底层原理。本书为学习 Node.js 的实现机制打开了一扇门。书中介绍的上下文（Context）、句柄（Handle）、句柄作用域（Handle Scope）等概念直接来自于源码，对于阅读 Node.js 及 V8 的源码具有极高的参考价值。</p>\n<p>——潘旻琦（pmq20），Node.js 技术专家，Node.js Collaborator 之一，RubyConf 讲师之一</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>国内 Node.js 偏向于原理的书目前只有朴灵的《深入浅出 Node.js》一本，至今 4 年过去了，Node.js 已经从 v0.10 发展到 v9 版本，中间再没有这样的系统的有深度的书籍。</p>\n<p>很高兴死月的新书弥补了这一遗憾。本书以 C++ 为主线，涵盖 Node.js 最核心的 libuv 和 V8，对理解 Node.js 原理有极大的好处。当然最大的好处在于使用 C++ 编写 Node.js Addon 可以让 Node.js 有更广阔的应用空间。我们都知道 Node.js 擅长的是 I/O 密集型任务，对于 CPU 密集型运算这是极好的弥补。</p>\n<p>特别推荐大家阅读此书，Node.js 应用极其广泛的今天，使用 C++ 编写 Node.js Addon 是更出彩的部分，你值得拥有。</p>\n<p>——桑世龙（狼叔），StuQ 明星讲师，Node.js 技术布道者，《更了不起的 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>死月对 Node.js 底层机制有非常深入的了解。阅读本书，除了学习 C++ 扩展开发，还会跟随死月了解 V8、libuv，相信读后大家对于 Node.js 的理解会更上一层楼。</p>\n<p>——孙信宇（芋头），大搜车无线架构团队负责人，前端乱炖站长</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>C++ 扩展其实是从外在，用 C++ 的角度去观察 Node.js 内在的形式。因为 Node.js 整个系统自身几乎就是构建在 C/C++ 之上的，只是内部称之为 built-in，在 user-land 则称之 Addon，它们本质上其实没有区别。死月凭借他在 C/C++ 的深厚积累，选择从 C++ 扩展作为突破口，带大家领略 Node.js 底层的风光，在书里，你能看到真正发挥巨大价值的 V8、libuv 亦是精彩纷呈。</p>\n<p>死月将 C++ 扩展写得这么透，我是服的。</p>\n<p>——田永强（朴灵），高级 Node.js 技术专家，《深入浅出 Node.js》作者</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>开发 C++ 扩展，可以扩充 Node.js 平台的本地 API，扩充 Node.js 应用的能力。这本书详细介绍了包括 libuv、V8 在内的各种必要知识，是该领域不可多得的好书。对 C++ 开发者来说，本书既可以作为入门指引，又可以作为日常开发的参考书。</p>\n<p>——王文睿博士（Roger Wang），node-webkit 和 NW.js 项目创始人和维护者，因特尔软件架构师</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>清晰记得手写的第一个 Node.js C++ 扩展模块，在 Node.js 0.6.9 跑通的那种愉悦感。随着应用升级到 Node.js 0.8，依赖的 C++ 扩展模块无法安装编译成功，最后发现是 V8 的 API 变化导致不兼容，从此对 C++ 扩展模块产生抗拒。后来看到《Node.js：来一打 C++ 扩展》，从实现原理，到 V8 基础概念的一系列介绍，让我重新对 C++ 扩展模块产生兴趣。参考书里的实战例子，以及 NAN 的辅助下，现在编写一个跨 Node.js 版本的 C++ 扩展已经不是什么困难的事情。通过最后一章节，可以了解到 Node.js 官方的 N-API 计划，让 C++ 扩展不仅仅能跨版本复用，还能跨操作系统（平台）复用。</p>\n<p>——袁锋（fengmk2），Node.js 技术专家</p>\n</blockquote>\n</div>",
      "title": "《Node.js：来一打 C++ 扩展》已出版，求支持",
      "last_reply_at": "2018-08-31T08:26:06.859Z",
      "good": true,
      "top": true,
      "reply_count": 111,
      "visit_count": 18853,
      "create_at": "2018-06-14T09:57:49.652Z",
      "author": {
        "loginname": "XadillaX",
        "avatar_url": "https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"
      }
    },
    {
      "id": "5a9661ff71327bb413bbff5b",
      "author_id": "5110f2bedf9e9fcc584e4677",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><img src=\"https://github.com/nswbmw/node-in-debugging/raw/master/assets/book.jpg\" alt>\n《Node.js 调试指南》是本人整理的从事 Node.js 开发这几年的一些调试经验和思路，希望授人以鱼亦能授人以渔。</p>\n<p>享受开源，支持正版~</p>\n<h2>购书链接</h2>\n<ul>\n<li><a href=\"http://product.dangdang.com/25278935.html\">当当</a></li>\n<li><a href=\"https://item.jd.com/12356929.html\">京东</a></li>\n<li><a href=\"https://s.taobao.com/search?q=Node.js%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97\">淘宝</a></li>\n<li><a href=\"https://www.amazon.cn/dp/B07D57FDY4/\">亚马逊</a></li>\n<li><a href=\"http://product.china-pub.com/8004731\">china-pub</a></li>\n</ul>\n<h2>目录</h2>\n<ul>\n<li>CPU 篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.1%20perf%20%2B%20FlameGraph.md\">perf + FlameGraph</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.2%20v8-profiler.md\">v8-profiler</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/1.3%20Tick%20Processor.md\">Tick Processor</a></li>\n</ul>\n</li>\n<li>内存篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.1%20gcore%20%2B%20llnode.md\">gcore + llnode</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.2%20heapdump.md\">heapdump</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.3%20memwatch-next.md\">memwatch-next</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/2.4%20cpu-memory-monitor.md\">cpu-memory-monitor</a></li>\n</ul>\n</li>\n<li>代码篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.1%20Promise.md\">Promise</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.2%20Async%20%2B%20Await.md\">Async + Await</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.3%20Error%20Stack.md\">Error Stack</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.4%20Node%408.md\">Node@8</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.5%20Rust%20Addons.md\">Rust Addons</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.6%20Event%20Loop.md\">Event Loop</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/3.7%20uncaughtException%20%2B%20llnode.md\">uncaughtException + llnode</a></li>\n</ul>\n</li>\n<li>工具篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.1%20Source%20Map.md\">Source Map</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.2%20Chrome%20DevTools.md\">Chrome DevTools</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.3%20Visual%20Studio%20Code.md\">Visual Studio Code</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.4%20debug%20%2B%20repl2%20%2B%20power-assert.md\">debug + repl2 + power-assert</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/4.5%20supervisor-hot-reload.md\">supervisor-hot-reload</a></li>\n</ul>\n</li>\n<li>APM 篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/5.1%20NewRelic.md\">NewRelic</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/5.2%20Elastic%20APM.md\">Elastic APM</a></li>\n</ul>\n</li>\n<li>日志篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.1%20koa-await-breakpoint.md\">koa-await-breakpoint</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.2%20async_hooks.md\">async_hooks</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.3%20ELK.md\">ELK</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.4%20OpenTracing%20%2B%20Jaeger.md\">OpenTracing + Jaeger</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/6.5%20Sentry.md\">Sentry</a></li>\n</ul>\n</li>\n<li>监控篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/7.1%20Telegraf%20%2B%20InfluxDB%20%2B%20Grafana(%E4%B8%8A).md\">Telegraf + InfluxDB + Grafana(上)</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/7.2%20Telegraf%20%2B%20InfluxDB%20%2B%20Grafana(%E4%B8%8B).md\">Telegraf + InfluxDB + Grafana(下)</a></li>\n</ul>\n</li>\n<li>应用篇\n<ul>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/8.1%20node-clinic.md\">node-clinic</a></li>\n<li><a href=\"https://github.com/nswbmw/node-in-debugging/blob/master/8.2%20alinode.md\">alinode</a></li>\n</ul>\n</li>\n</ul>\n</div>",
      "title": "《Node.js 调试指南》已出版",
      "last_reply_at": "2018-08-31T02:53:59.740Z",
      "good": true,
      "top": true,
      "reply_count": 110,
      "visit_count": 25083,
      "create_at": "2018-02-28T08:02:07.081Z",
      "author": {
        "loginname": "nswbmw",
        "avatar_url": "https://avatars0.githubusercontent.com/u/4279697?v=4&s=120"
      }
    },
    {
      "id": "5b890b75632c7f422e5b8343",
      "author_id": "5a60112e9288dc8153287f22",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>egg一定要在config.default.js里的所有配置都连上之后，才能启动服务吗？\n\t有一个连不上就报错，业务复杂配置多的时候这样是不是不太好？</p>\n</div>",
      "title": "egg一定要连上数据库才能启动服务吗",
      "last_reply_at": "2018-08-31T09:59:17.734Z",
      "good": false,
      "top": false,
      "reply_count": 1,
      "visit_count": 40,
      "create_at": "2018-08-31T09:33:41.227Z",
      "author": {
        "loginname": "dryqiao",
        "avatar_url": "https://avatars0.githubusercontent.com/u/17639218?v=4&s=120"
      }
    },
    {
      "id": "5b49c45913ca2fe569fb93ae",
      "author_id": "5b00d7d09ac7d98106556392",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><blockquote>\n<p>先说明下，转python不仅仅是就学习下语法，语法几天就能熟悉了。主要是像利用numpy、pandas等做一些事情。</p>\n</blockquote>\n<ul>\n<li>\n<p>这条道路很陡，学习成本很显然，只是基于兴趣，同时也希望在薪资上也能有好的收获（并不是说前端不如人工智能薪资高，不要误解我的意思）。</p>\n</li>\n<li>\n<p>前端本身就有很多要学的技术，现在大前端技术也在学习提升阶段。那是不是就不该把经历放到学习人工智能上（只是人工智能的某个领域而已）。</p>\n</li>\n<li>\n<p>希望大家给点自我看法。</p>\n</li>\n</ul>\n</div>",
      "title": "前端转python，以此为突破口往人工智能方向发展",
      "last_reply_at": "2018-08-31T09:49:30.867Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 805,
      "create_at": "2018-07-14T09:37:29.510Z",
      "author": {
        "loginname": "ruizhengyun",
        "avatar_url": "https://avatars2.githubusercontent.com/u/6204303?v=4&s=120"
      }
    },
    {
      "id": "5b88ede8fad9359e2e831390",
      "author_id": "580dc019eae2a24f34e67e60",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>小程序分享的时候，有的android机器，分享出来的小程序会是黑屏的， 有遇到过这种情况的同学没， 有解决方案吗 ?\n<img src=\"//dn-cnode.qbox.me/FmI2UGw2bXYycGqpInP75sPTR52W\" alt=\"WechatIMG1147.jpeg\"></p>\n</div>",
      "title": "有做小程序的同学，帮忙看一个问题，关于分享黑屏的",
      "last_reply_at": "2018-08-31T09:33:40.810Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 86,
      "create_at": "2018-08-31T07:27:36.658Z",
      "author": {
        "loginname": "liujavamail",
        "avatar_url": "https://avatars2.githubusercontent.com/u/7991288?v=4&s=120"
      }
    },
    {
      "id": "5b890abb08d0b0fb2d8e6dab",
      "author_id": "545b74143e1f39344c5b3bee",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>豆瓣音乐用的mp3，Chromium可以正常播放\nFM就没法播放了\n同样是音频，都用最通用的mp3不是挺好么？</p>\n</div>",
      "title": "豆瓣FM，音频为什么选用mp4文件，用mp3不是挺好的么？有人能从技术上给个解释么",
      "last_reply_at": "2018-08-31T09:30:35.338Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 31,
      "create_at": "2018-08-31T09:30:35.338Z",
      "author": {
        "loginname": "chapgaga",
        "avatar_url": "https://avatars0.githubusercontent.com/u/9590859?v=4&s=120"
      }
    },
    {
      "id": "5b88a70108d0b0fb2d8e6d6b",
      "author_id": "5b804123a210553a0cde2bfc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>每天阅读一个 npm 模块（4）- throttle-debounce</h1>\n<p>系列文章：</p>\n<ol>\n<li><a href=\"https://cnodejs.org/topic/5b8041eec52ad1482eb941ce\">每天阅读一个 npm 模块（1）- username</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b82dd11632c7f422e5b815a\">每天阅读一个 npm 模块（2）- mem</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b84d3752a585e4e2f26ff5b/edit\">每天阅读一个 npm 模块（3）- mimic-fn</a></li>\n</ol>\n<p>上一篇文章中介绍的属性描述符的知识太偏于理论，今天阅读的 <a href=\"https://www.npmjs.com/package/throttle-debounce\">throttle-debounce</a> 模块会实用许多，在工作常常可以用到。</p>\n<h2>一句话介绍</h2>\n<p>今天阅读的 npm 模块是 <a href=\"https://www.npmjs.com/package/throttle-debounce\">throttle-debounce</a>，它提供了 <code>throttle</code> 和 <code>debounce</code> 两个函数：throttle 的含义是节流，debounce 的含义是防抖动，通过它们可以限制函数的执行频率，避免短时间内函数多次执行造成性能问题，当前包版本为 2.0.1，周下载量为 6.3 万。</p>\n<h2>用法</h2>\n<p>首选需要介绍一下 <code>throttle</code> 和 <code>debounce</code> ，它们都可以用于 <strong>函数节流</strong> 从而提升性能，但它们还是存在一些不同：</p>\n<ul>\n<li>debounce：将短时间内多次触发的事件合并成一次事件响应函数执行（往往是在第一次事件或者在最后一次事件触发时执行），即该段时间内仅<strong>一次</strong>真正执行事件响应函数。</li>\n<li>throttle：假如在短时间内同一事件多次触发，那么每隔一段更小的时间间隔就会执行事件响应函数，即该段时间内可能<strong>多次</strong>执行事件响应函数。</li>\n</ul>\n<p>虽然每天最烦等电梯要花上十几分钟，但还是可以用坐电梯来举例子：</p>\n<ul>\n<li>debounce：假如我在电梯里面正准备关门，这时 A 想要坐电梯，那么出于礼貌我会按下开门键，然后等他走进电梯后再尝试关门；等 A 进电梯后，又发现 B 也想要坐电梯，那么同样出于礼貌我会按下开门键，然后等他走进电梯。那么假如一直有人想要坐电梯的话，我就会不断地延后按下关门键的时机，直至没有人想要坐电梯（现实生活中我这样做的话，估计每天除了坐电梯就可以什么都不做了）。</li>\n<li>throttle：实际上我每天都有工作要完成，不可能在电梯里无限地等别人。那么这回我任性一点，规定我只等 30 秒，不管到时候有没有人想要坐电梯，我都会按下关门键走掉。</li>\n</ul>\n<p>从上面两个例子中可以看出两者最大的区别在于只要有事件发生（有人想坐电梯），若使用了 <code>throttle</code> 方法，那么在一段时间内事件响应函数一定会执行（30秒内我按下关门键）；若使用了 <code>debounce</code> 方法，那么只有事件停止发生后（我发现没有人想坐电梯）才会执行。</p>\n<p>大家可以尝试在 <a href=\"https://codepen.io/elvinn/pen/BOLbBY\">Code Pen -Demo</a> 中滚动鼠标直观地感受到这两者的不同。</p>\n<p>对于 <a href=\"https://www.npmjs.com/package/throttle-debounce\">throttle-debounce</a>，它的简单用法如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>import { throttle, debounce } from &#x27;throttle-debounce&#x27;;\n\nfunction foo() { console.log(&#x27;foo..&#x27;); }\nfunction bar() { console.log(&#x27;bar..&#x27;); }\n\nconst fooWrapper = throttle(200, foo);\n\nfor (let i = 1; i &lt; 10; i++) {\n  setTimeout(fooWrapper, i * 30);\n}\n\n&#x2F;&#x2F; =&gt; foo 执行了三次\n&#x2F;&#x2F; =&gt; foo..\n&#x2F;&#x2F; =&gt; foo..\n&#x2F;&#x2F; =&gt; foo..\n\nconst barWrapper = debounce(200, bar);\n\nfor (let i = 1; i &lt; 10; i++) {\n  setTimeout(barWrapper, i * 30);\n}\n\n&#x2F;&#x2F; =&gt; bar 执行了一次 \n&#x2F;&#x2F; =&gt; bar..\n\n</code></pre><h2>源码学习</h2>\n<h3>throttle 实现</h3>\n<p>将源码简化后适当修改如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源码 4-1\nfunction throttle(delay, callback) {\n  let timeoutID;\n  let lastExec = 0;\n\n  function wrapper() {\n    const self = this;\n    const elapsed = Number(new Date()) - lastExec;\n    const args = arguments;\n\n    function exec() {\n      lastExec = Number(new Date());\n      callback.apply(self, args);\n    }\n\n    clearTimeout(timeoutID);\n\n    if (elapsed &gt; delay) {\n      exec();\n    } else {\n      timeoutID = setTimeout(exec, delay - elapsed);\n    }\n  }\n\n  return wrapper;\n}\n</code></pre><p>整个代码的逻辑十分清晰，一共只有三步：</p>\n<ol>\n<li>计算距离最近一次函数执行后经过的时间 <code>elapsed</code>，并清除之前设置的计时器。</li>\n<li>如果经过的时间大于设置的时间间隔 <code>delay</code>，那么立即执行函数，并更新最近一次函数的执行时间。</li>\n<li>如果经过的时间小于设置的时间间隔 <code>delay</code>，那么通过 <code>setTimeout</code> 设置一个计数器，让函数在 <code>delay - elapsed</code> 时间后执行。</li>\n</ol>\n<p>源码 4-1 并不难理解，不过需要关注一下 <code>this</code> 的使用：</p>\n<pre class=\"prettyprint language-javascript\"><code>function throttle(delay, callback) {\n    &#x2F;&#x2F; ...\n    function wrapper() {\n    \tconst self = this;\n        const args = arguments;\n        &#x2F;&#x2F; ...\n        \n        function exec() {\n            &#x2F;&#x2F; ...\n\t      \tcallback.apply(self, args);\n    \t}\n        \n    }\n}\n</code></pre><p>在上面的代码中，通过 <code>self</code> 变量临时保存 <code>this</code> 的值，从而在 <code>exec</code> 函数中通过 <code>callback.apply(self, args)</code> 传入正确的 <code>this</code> 值，这种做法在<strong>闭包</strong>相关的函数调用中十分常用。正因为这里对 <code>this</code> 的处理，所以可以实现下面的能力：</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo() { console.log(this.name);  }\n\nconst fooWithName = throttle(200, foo);\n\nconst obj = {name: &#x27;elvin&#x27;};\n\nfooWithName.call(obj, &#x27;elvin&#x27;);\n\n&#x2F;&#x2F; =&gt; &#x27;elvin&#x27;\n</code></pre><h3>debounce 实现</h3>\n<p>由于 <code>debounce</code>n 只是往后推延函数的执行时间，并不具有 <code>throttle</code> 每隔一段时间一定会执行的能力，所以其实现起来更加简单：</p>\n<pre class=\"prettyprint language-javascript\"><code>function debounce(delay, callback) {\n  let timeoutID;\n\n  function wrapper() {\n    const self = this;\n    const args = arguments;\n\n    function exec() {\n      callback.apply(self, args);\n    }\n\n    clearTimeout(timeoutID);\n\n    timeoutID = setTimeout(exec, delay);\n  }\n\n  return wrapper;\n}\n</code></pre><p>将上述代码与 <code>throttle</code> 实现的代码相比，可以发现其就是去除了 <code>elapsed</code> 相关逻辑后的代码，其余大部分代码一模一样，所以 <code>debounce</code> 函数可以借助 <code>throttle</code>  函数实现（<a href=\"https://www.npmjs.com/package/throttle-debounce\">throttle-debounce</a> 源代码中也是这样做的），<code>throttle</code>  函数也可以借助 <code>debounce</code> 函数实现。</p>\n<h3>throttle 和 debounce 使用场景举例</h3>\n<p><code>throttle</code> 和 <code>debounce</code> 适用于用户短时间内频繁执行某一相同操作的场景，例如：</p>\n<ul>\n<li>用户拖动浏览器窗口改变窗口大小，触发 <code>resize</code> 事件。</li>\n<li>用户移动鼠标，触发 <code>mousemove</code> 等事件。</li>\n<li>用户在输入框内进入输入，触发 <code>keydown</code> | <code>keypress</code> | <code>keyinput</code> | <code>keyup</code> 等事件。</li>\n<li>用户滚动屏幕，触发 <code>scroll</code> 事件。</li>\n<li>用户在点击按钮后，由于 API 请求耗时未立即看到响应，可能会不断点击按钮触发 <code>click</code> 事件。</li>\n</ul>\n<p>在网上搜索了不少资料，发现对两个函数的使用场景有时彼此之间都互相矛盾，例如有的说在搜索框进行输入，应该使用 <code>debounce</code> 进行限流，从而减轻服务器压力；有的说使用 <code>throttle</code> 进行限流即可，可以更快地返回用户的搜索结果。</p>\n<p>在我看来，并不存在一个场景，就一定是使用 <code>throttle</code> 和 <code>debounce</code> 中的一种方法并另外一种方法好，往往需要结合自身的情况进行考虑和选择：</p>\n<ul>\n<li>当事件响应函数对 CPU、GPU、流量、服务器等资源的占用在接受范围内时，可以使用 <code>throttle</code> 进行限流带来更好的用户体验。</li>\n<li>当事件响应函数对 CPU、GPU、流量、服务器等资源的占用较大时，可以使用 <code>debounce</code> 进行更强力的限流，从而减轻压力。</li>\n</ul>\n<h2>写在最后</h2>\n<p><a href=\"https://www.npmjs.com/package/throttle-debounce\">throttle-debounce</a> 源码和我前几天所看的 <a href=\"https://github.com/sindresorhus\">Sindre</a> 所写的模块代码风格完全不同，它的代码中注释的行数约为代码行数的三倍，而且函数的参数均有详细的注释，这本应是一件好事，但是对于我阅读源码而言，并没有觉得更加轻松，而求由于对可选参数进行的如下处理，让我阅读起来更加费力：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源码 4-2\n\n&#x2F;**\n *\n * @param  {Number}    delay\n * @param  {Boolean}   [noTrailing]\n * @param  {Function}  callback\n * @param  {Boolean}   [debounceMode]\n *\n * @return {Function}  A new, throttled, function.\n *&#x2F;\nexport default function ( delay, noTrailing, callback, debounceMode ) {\n    &#x2F;&#x2F; &#96;noTrailing&#96; defaults to falsy.\n\tif ( typeof noTrailing !== &#x27;boolean&#x27; ) {\n\t\tdebounceMode = callback;\n\t\tcallback = noTrailing;\n\t\tnoTrailing = undefined;\n\t}\n    \n    &#x2F;&#x2F; ...\n}\n</code></pre><p>在源码 4-2 中，从注释可以看出 <code>noTrailing</code> 和 <code>debounceMode</code> 是可选参数，<code>delay</code> 和 callback 为必选参数，然后它将可选参数 <code>noTrailing</code> 放在了必选参数 <code>callback</code> 之前，再在函数中的代码进行判断：假如 <code>noTrailing</code> 为函数的话，则此值应作为 <code>callback</code>，然后再将 <code>noTrailing</code> 设为默认值 <code>undefined</code>。</p>\n<p>不禁感叹这真是一番骚操作，哪怕是为了兼容 ES5，也有更好的写法，这里说说我个人认为可用 ES6 语法时更好的写法：</p>\n<pre class=\"prettyprint language-javascript\"><code>export default function (dalay, noTrailing, options = {\n    callback = false,\n    debounceMode = false,\n} = {}) {\n    &#x2F;&#x2F; ...\n}\n</code></pre><blockquote>\n<p>关于我：毕业于华科，工作在腾讯，<a href=\"https://segmentfault.me/\">elvin 的博客</a> 欢迎来访 ^_^</p>\n</blockquote>\n</div>",
      "title": "每天阅读一个 npm 模块（4）- throttle-debounce",
      "last_reply_at": "2018-08-31T08:39:50.279Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 189,
      "create_at": "2018-08-31T02:25:05.410Z",
      "author": {
        "loginname": "elvinn",
        "avatar_url": "https://avatars0.githubusercontent.com/u/28722527?v=4&s=120"
      }
    },
    {
      "id": "5b82dd11632c7f422e5b815a",
      "author_id": "5b804123a210553a0cde2bfc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>每天阅读一个 npm 模块（2）- mem</h1>\n<p>系列文章：</p>\n<ol>\n<li><a href=\"https://cnodejs.org/topic/5b8041eec52ad1482eb941ce\">每天阅读一个 npm 模块（1）- username</a></li>\n</ol>\n<p>昨天阅读 <a href=\"https://www.npmjs.com/package/username\">username</a> 3.0.0 版本的源码之后，根据自己的想法向作者 Sindre Sorhus 提出了 <a href=\"https://github.com/sindresorhus/username/pull/20\">Pull Request</a>，没想到今天 Sindre 接受了 PR 同时放弃了对 Node 4 的支持，升级至 4.0.0 版本，不过核心代码并有太大的变化 😊</p>\n<h2>一句话介绍</h2>\n<p>今天阅读的 npm 模块是 <a href=\"https://www.npmjs.com/package/mem\">mem</a>，它通过缓存函数的返回值从而减少函数的实际执行次数，进而提升性能，当前版本为 3.0.1，周下载量约为 350 万。</p>\n<h2>用法</h2>\n<pre class=\"prettyprint language-javascript\"><code>const mem = require(&#x27;mem&#x27;);\n \n&#x2F;&#x2F; 同步函数缓存\nlet i = 0;\nconst counter = () =&gt; ++i;\nconst memoized = mem(counter);\n \nmemoized(&#x27;foo&#x27;);\n&#x2F;&#x2F;=&gt; 1\n \nmemoized(&#x27;foo&#x27;);\n&#x2F;&#x2F;=&gt; 1   参数相同，返回换成的结果 1\n \nmemoized(&#x27;bar&#x27;);\n&#x2F;&#x2F;=&gt; 2   参数变化，counter 函数再次执行，返回 2\n \nmemoized(&#x27;bar&#x27;);\n&#x2F;&#x2F;=&gt; 2\n\n&#x2F;&#x2F; 异步函数缓存\nlet j = 0;\nconst asyncCounter = () =&gt; Promise.resolve(++j);\nconst asyncmemoized = mem(asyncCounter);\n\nasyncmemoized().then(a =&gt; {\n    console.log(a);\n    &#x2F;&#x2F;=&gt; 1\n \n    asyncmemoized().then(b =&gt; {\n        console.log(b);\n        &#x2F;&#x2F;=&gt; 1\n    });\n});\n</code></pre><p>上述用法是 <a href=\"https://www.npmjs.com/package/mem\">mem</a> 的核心功能，除此之外它还支持 设置缓存时间、自定义缓存 Hash 值、统计缓存命中数据等功能。</p>\n<h2>源码学习</h2>\n<h3>哈希函数</h3>\n<p>为了让被 <code>mem</code> 处理过的函数对于相同的参数能返回同样的值，那么就必须对参数进行哈希处理，然后将哈希结果作为 <code>key</code>，函数运行结果作为 <code>value</code> 缓存起来，举一个最简单的例子:</p>\n<pre class=\"prettyprint language-javascript\"><code>const cache = {};\n\n&#x2F;&#x2F; 缓存 arg1 的运行结果\nconst key1 = getHash(arg1);\ncache[key1] = func(arg1);\n\n&#x2F;&#x2F; 缓存 arg2 的运行结果\nconst key2 = getHash(arg2);\ncache[key2] = func(arg2);\n</code></pre><p>其中的关键在于 <code>getHash</code> 这个哈希函数：如何处理不同的数据类型？如何处理对象间的比较？其实这也是面试中经常被问到的问题：如何进行深比较？来看看源代码中是怎么写的：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源代码 2-1: mem 的哈希函数\nconst defaultCacheKey = (...args) =&gt; {\n\tif (args.length === 1) {\n\t\tconst [firstArgument] = args;\n\t\tif (\n\t\t\tfirstArgument === null ||\n\t\t\tfirstArgument === undefined ||\n\t\t\t(typeof firstArgument !== &#x27;function&#x27; &amp;&amp; typeof firstArgument !== &#x27;object&#x27;)\n\t\t) {\n\t\t\treturn firstArgument;\n\t\t}\n\t}\n\n\treturn JSON.stringify(args);\n};\n</code></pre><p>从上面的代码中可以看到：</p>\n<ol>\n<li>当只有一个参数，且参数为 null | undefined 或者类型不为 function | object 时，哈希函数直接将参数返回。</li>\n<li>若不是上述情况，则返回参数经过 <code>JSON.stringify()</code> 的值。</li>\n</ol>\n<p>首先可以复习一下 ES6 中定义了其中数据类型，包括 6 种原始类型（Boolean | Nunber | Null | Undefined | String| Symbol）和 Object 类型。源代码中的哈希函数需要对不同的类型加以区分是因为 Object 类型的直接比较结果和我们这里需要达成的效果不符合：</p>\n<pre class=\"prettyprint language-javascript\"><code>const object1 = {a: 1};\nconst object2 = {a: 1};\n\nconsole.log(object1 === object2);\n&#x2F;&#x2F; =&gt; flase\n\n&#x2F;&#x2F; 期望效果\nconsole.log(defaultCacheKey(object1) === defaultCacheKey(object2));\n&#x2F;&#x2F; =&gt; true\n</code></pre><p>一开始我以为作者会通过判断不同的数据类型后再进行专门的处理（类似于 <a href=\"https://github.com/lodash/lodash/blob/4.17.10/lodash.js#L11530\">Lodash 的 _.isEqual() 实现</a>），没想到采用的方法这么暴力：直接将 Object 类型的数据通过 <code>JSON.stringify()</code> 转化为字符串后进行处理！刚看到的我是惊呆了的 —— 以前只听有人开玩笑这么干，没想到真会这么做。</p>\n<p>这种方法十分简单，而且可读性很高，但是会存在问题：</p>\n<ol>\n<li>\n<p>当对象结构复杂时，<code>JSON.stringify()</code> 会消耗不少时间。</p>\n</li>\n<li>\n<p>对于不同的正则对象，<code>JSON.stringify()</code> 的结果均为 <code>{}</code>，与哈希函数的预期效果不符。</p>\n<pre class=\"prettyprint language-javascript\"><code>console.log(JSON.stringify(&#x2F;Sindre Sorhus&#x2F;));\n&#x2F;&#x2F; =&gt; &#x27;{}&#x27;\n\nconsole.log(JSON.stringify(&#x2F;Elvin Peng&#x2F;));\n&#x2F;&#x2F; =&gt; &#x27;{}&#x27;\n</code></pre></li>\n</ol>\n<p>第一个问题还好，因为假如通过 <code>JSON.stringify()</code> 哈希时，性能存在问题的话，<code>mem</code> 支持传入自定义的哈希函数，可以通过自行编写高效哈希函数进行解决。</p>\n<p>第二个问题属于函数功能不符合预期，需要进行 bugfix。</p>\n<h3>存储结构</h3>\n<p>不考虑额外参数时，对于同步函数的支持源代码可简化如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源代码 2-2 mem 核心逻辑\nconst mimicFn = require(&#x27;mimic-fn&#x27;);\n\nconst cacheStore = new WeakMap();\n\nmodule.exports = (fn) =&gt; {\n    const memoized = function (...args) {\n        const cache = cacheStore.get(memoized);\n        const key = defaultCacheKey(...args);\n        \n        if (cache.has(key)) {\n            const c = cache.get(key);\n            return c.data;\n        }\n\n        const ret = fn.call(this, ...args);\n        \n        const setData = (key, data) =&gt; {\n            cache.set(key, {\n                data,\n            });\n        };\n        \n        setData(key, ret);\n        \n        return ret;\n    }\n    \n    const retCache = new Map();\n   \n    mimicFn(memoized, fn);\n\n    cacheStore.set(memoized, retCache);\n\n    return memoized;\n}\n\n\n\n</code></pre><p>整体逻辑十分清晰，主要是完成两个动作：</p>\n<ol>\n<li>将类型为 <code>Map</code> 的 <code>retCache</code> 作为函数执行结果的缓存，缓存的键值为 <code>defaultCacheKey</code> 哈希后的结果。</li>\n<li>将类型为 <code>WeakMap</code> 的 <code>cacheStore</code> 作为整体的缓存，缓存的键值为函数本身。</li>\n</ol>\n<p>通过上面两个动作形成的二级缓存实现了模块的核心功能，这里两个类型的选择非常值得探究。</p>\n<p><code>retCache</code> 选用 <code>Map</code> 类型而不用 <code>Object</code> 类型主要是因为 <code>Map</code> 的键值支持所有类型，而 <code>Object</code> 的键值只支持字符串，除此之外，关于缓存数据结构优选选择 <code>Map</code> 类型还有以下优点：</p>\n<ul>\n<li><code>Map.size</code> 属性可以方便的获得当前缓存的个数</li>\n<li><code>Map</code> 类型支持 <code>clear()</code> | <code>forEach()</code> 等常用的工具函数</li>\n<li><code>Map</code> 类型是默认可迭代的，即支持 <code>iterable protocol</code></li>\n</ul>\n<p><code>cacheStore</code> 选用 <code>WeakMap</code> 类型而不用 <code>Map</code> 类型主要是因为其具有不增加引用个数的优点，更有利于 Node.js 引擎的垃圾回收。</p>\n<h3>异步支持</h3>\n<p>本来还打算写一写关于异步支持的部分，不过现在已经是凌晨一点，想想还是算了吧，早点睡觉 😪</p>\n<p>感兴趣的朋友可以自己阅读～</p>\n<h2>写在最后</h2>\n<p>除了上文提到的一个 Bug 之外，<code>mem</code> 还存在内存泄漏的可能性：当缓存的数据已过期后（即被缓存的时间大于设置的 maxAge）并不会被自动清除，这可能造成当缓存的数据过多之后其无效缓存占据的内存无法被及时释放，从而导致内存泄漏，具体的讨论可以见<a href=\"https://github.com/sindresorhus/mem/issues/14\">Issue #14: Memory leak: old results are not deleted from the cache</a>。</p>\n<p>在源代码 2-2 的解读中故意略去了 <code>mimicFn(memoized, fn);</code> 的作用，为什么呢？因为明天准备阅读 <a href=\"https://www.npmjs.com/package/mimic-fn\">mimicFn</a> 这个模块，希望大家能继续捧场。</p>\n<blockquote>\n<p>关于我：毕业于华科，工作在腾讯，<a href=\"https://segmentfault.me/\">elvin 的博客</a> 欢迎来访 ^_^</p>\n</blockquote>\n</div>",
      "title": "每天阅读一个 npm 模块（2）- mem",
      "last_reply_at": "2018-08-31T07:56:51.220Z",
      "good": false,
      "top": false,
      "reply_count": 11,
      "visit_count": 656,
      "create_at": "2018-08-26T17:02:09.518Z",
      "author": {
        "loginname": "elvinn",
        "avatar_url": "https://avatars0.githubusercontent.com/u/28722527?v=4&s=120"
      }
    },
    {
      "id": "5ae935101b02288048bd0b97",
      "author_id": "57553134397b615d0ebe0820",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p><strong>内容简介</strong></p>\n<p>JavaScript 是目前非常流行的一门语言，通过借助 Node.js 运行于浏览器之外，赋予了 JavaScript 强大的生命力。本书主要讲授了如何基于 JavaScript 技术栈，与阿里巴巴企业级 Node.js 框架 Egg.js 开发一个简易版 Dribble 应用产品。</p>\n<p>并讲解了如何从一个技术人的角度去看待独立产品开发的流程，哪些科学的方法我们是可以值得一试，以及有哪些好用的工具，包括设计、开发、调优、运维等方面的一些经验。本书都将带你一一实践，得出真知。</p>\n<p>为了方便读者学习，所有代码都将放到 Github 上面，大家可以自行下载查阅。</p>\n<p><a href=\"https://github.com/MiYogurt/nodejs_shizhan\">https://github.com/MiYogurt/nodejs_shizhan</a></p>\n<p><strong>写作思路</strong></p>\n<p>从一个技术人的角度出发，如何利用自身技术人的优势？基于 JavaScript 语言，使用阿里巴巴的企业级 Node.js 开源框架Egg.js完成后端开发。前端则使用 Vue.js 构建交互页面，并完成服务端渲染，解决 SEO 顾虑，达成前后端分离。并落地实践 DevOps 与容器化应用，达到快速迭代产品、无痛的横向扩展的目的。</p>\n<p>适合初、中级有意向往全栈发展的前端开发工程师，同时对希望制作一个自己的产品相关技术人员也有所帮助。</p>\n<p>目录如下，一共8章，全文 38w 字左右，具体多少页，编辑老师说 350 页起步。还在修订，最迟8月份。</p>\n<ul>\n<li>\n<p><a href=\"#toc_0\">为什么是 JavaScript 语言？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_1\">低成本</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_2\">非常流行</a></p>\n</li>\n<li>\n<p><a href=\"#toc_3\">运用范围广</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_4\">为什么 Node.js 经常被说不适合大型应用？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_5\">应用的组成</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_6\">应用的种类</a></p>\n</li>\n<li>\n<p><a href=\"#toc_7\">应用服务的过程</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_8\">Request 请求过程</a></p>\n<ul>\n<li><a href=\"#toc_9\">Response 返回过程</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_10\">应用的瓶颈</a></p>\n</li>\n<li>\n<p><a href=\"#toc_11\">分布式应用</a></p>\n</li>\n<li>\n<p><a href=\"#toc_12\">多进程的 Node.js</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_13\">安装 Node.js</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_14\">Windows</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_15\">Mac</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_16\">方式一</a></p>\n<ul>\n<li><a href=\"#toc_17\">方式二</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_18\">Linux</a></p>\n</li>\n<li>\n<p><a href=\"#toc_19\">更改 npm 源地址为淘宝源</a></p>\n</li>\n<li>\n<p><a href=\"#toc_20\">如何更新 npm</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_21\">什么样的产品才是好产品？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_22\">痛点</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_23\">痒点</a></p>\n</li>\n<li>\n<p><a href=\"#toc_24\">卖点</a></p>\n</li>\n<li>\n<p><a href=\"#toc_25\">答案</a></p>\n</li>\n<li>\n<p><a href=\"#toc_26\">怎样去做一个产品？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_27\">产品是否值得去做？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_28\">如何调研？</a></p>\n</li>\n<li>\n<p><a href=\"#toc_29\">计划与规划</a></p>\n</li>\n<li>\n<p><a href=\"#toc_30\">提炼需求</a></p>\n</li>\n<li>\n<p><a href=\"#toc_31\">设计</a></p>\n</li>\n<li>\n<p><a href=\"#toc_32\">开发</a></p>\n</li>\n<li>\n<p><a href=\"#toc_33\">上线</a></p>\n</li>\n<li>\n<p><a href=\"#toc_34\">阶段性产出</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_35\">分析与调研</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_36\">SWOT</a></p>\n<ul>\n<li><a href=\"#toc_37\">调研</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_38\">制定计划</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_39\">制定计划的好处</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_40\">什么是甘特图？</a></p>\n</li>\n<li>\n<p><a href=\"#toc_41\">画甘特图</a></p>\n</li>\n<li>\n<p><a href=\"#toc_42\">小结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_43\">需求分析</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_44\">用户故事例子</a></p>\n<pre class=\"prettyprint\"><code>*   [小 A 的故事](#toc_45)\n\n    *   [小 B 的故事](#toc_46)\n\n    *   [小 C 的故事](#toc_47)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_48\">需求到功能</a></p>\n</li>\n<li>\n<p><a href=\"#toc_49\">功能到界面</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_50\">分析页面元素</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_51\">取色</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_52\">页首</a></p>\n</li>\n<li>\n<p><a href=\"#toc_53\">页尾</a></p>\n</li>\n<li>\n<p><a href=\"#toc_54\">首页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_55\">登陆页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_56\">忘记密码页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_57\">注册页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_58\">个人中心页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_59\">博客列表页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_60\">播客 FM 列表页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_61\">画廊详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_62\">博客详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_63\">播客 FM 详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_64\">博客编辑页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_65\">画廊编辑页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_66\">团队相关页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_67\">总结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_68\">设计公共区域</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_69\">获取 Sketch</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_70\">Sketch 界面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_71\">顶栏</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_72\">左边栏</a></p>\n</li>\n<li>\n<p><a href=\"#toc_73\">右边栏</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_74\">设计页首</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_75\">创建背景</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_76\">打开网格</a></p>\n</li>\n<li>\n<p><a href=\"#toc_77\">添加 logo</a></p>\n</li>\n<li>\n<p><a href=\"#toc_78\">插入文字</a></p>\n</li>\n<li>\n<p><a href=\"#toc_79\">创建组件模板</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_80\">设计页脚</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_81\">背景</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_82\">Logo 与社会化链接</a></p>\n</li>\n<li>\n<p><a href=\"#toc_83\">友情链接与关于</a></p>\n</li>\n<li>\n<p><a href=\"#toc_84\">活动与统计</a></p>\n</li>\n<li>\n<p><a href=\"#toc_85\">最终效果</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_86\">设计首页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_87\">做一些调整</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_88\">安装图标字体包</a></p>\n</li>\n<li>\n<p><a href=\"#toc_89\">设计筛选</a></p>\n</li>\n<li>\n<p><a href=\"#toc_90\">设计画廊容器</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_91\">快速图片技巧</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_92\">模板组件的插入</a></p>\n</li>\n<li>\n<p><a href=\"#toc_93\">快速排列</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_94\">设计登陆相关页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_95\">设计登陆页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_96\">注册页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_97\">忘记密码页</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_98\">设计个人中心相关页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_99\">我的画廊</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_100\">我的邀请码</a></p>\n</li>\n<li>\n<p><a href=\"#toc_101\">我的团队</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_102\">顶部导航链接相关页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_103\">博客列表页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_104\">博客详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_105\">FM 列表页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_106\">FM 详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_107\">团队列表页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_108\">团队详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_109\">画廊详情页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_110\">小节</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_111\">设计数据库与数据关系</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_112\">确认表</a></p>\n<pre class=\"prettyprint\"><code>*   [User 表](#toc_113)\n\n    *   [Invitation 表](#toc_114)\n\n    *   [Image 表](#toc_115)\n\n    *   [ImageComment 表](#toc_116)\n\n    *   [Post 表](#toc_117)\n\n    *   [PostComment 表](#toc_118)\n\n    *   [Category 表](#toc_119)\n\n    *   [Tag 表](#toc_120)\n\n    *   [TagInfo](#toc_121)\n\n    *   [FM 表](#toc_122)\n\n    *   [Team 表](#toc_123)\n\n    *   [TeamStatus 表](#toc_124)\n\n    *   [Order 表](#toc_125)\n</code></pre><ul>\n<li><a href=\"#toc_126\">小结</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_127\">异步基础</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_128\">什么是异步</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_129\">回调实现异步</a></p>\n</li>\n<li>\n<p><a href=\"#toc_130\">事件实现异步</a></p>\n</li>\n<li>\n<p><a href=\"#toc_131\">观察者模式实现异步</a></p>\n</li>\n<li>\n<p><a href=\"#toc_132\">Promise 异步</a></p>\n</li>\n<li>\n<p><a href=\"#toc_133\">async/await 大杀器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_134\">小结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_135\">koa.js 基础</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_136\">Koa.js 中间件核心代码</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_137\">Koa.js 插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_138\">使用中间件</a></p>\n<ul>\n<li><a href=\"#toc_139\">创建一个中间件</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_140\">小结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_141\">Egg.js 基础</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_142\">实现 egg-core</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_143\">实现 egg-init</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_144\">使用 egg-init</a></p>\n<ul>\n<li><a href=\"#toc_145\">egg-init 的原理</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_146\">实现 egg-cluster</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_147\">Egg.js 插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_148\">egg-socket.io</a></p>\n<pre class=\"prettyprint\"><code>*   [如何使用](#toc_149)\n\n    *   [最小运行实例](#toc_150)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_151\">原理解读</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_152\">目录约定</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_153\">添加建立连接中间件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_154\">添加发包中间件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_155\">中间件初始化</a></p>\n</li>\n<li>\n<p><a href=\"#toc_156\">命名空间与事件名称（路由）</a></p>\n</li>\n<li>\n<p><a href=\"#toc_157\">添加一些帮助方法</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_158\">制作一个 Egg.js 插件</a></p>\n<ul>\n<li>\n<ul>\n<li>\n<p><a href=\"#toc_159\">初始化项目</a></p>\n<pre class=\"prettyprint\"><code>*   [声明默认配置](#toc_160)\n\n*   [创建中间件](#toc_161)\n\n*   [建立视图](#toc_162)\n\n*   [插入中间件](#toc_163)\n\n*   [手动测试](#toc_164)\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_165\">安装相关组件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_166\">初始化</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_167\">准备数据库配置</a></p>\n</li>\n<li>\n<p><a href=\"#toc_168\">Sequelize API</a></p>\n</li>\n<li>\n<p><a href=\"#toc_169\">User 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_170\">Invitation 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_171\">Image 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_172\">ImageComment 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_173\">Post 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_174\">PostComment 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_175\">Category 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_176\">Tag 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_177\">TagInfo 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_178\">FM 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_179\">Team 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_180\">TeamStatus 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_181\">Order 表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_182\">查看migration 状态</a></p>\n</li>\n<li>\n<p><a href=\"#toc_183\">代码写错了怎么办</a></p>\n</li>\n<li>\n<p><a href=\"#toc_184\">进行同步到数据库</a></p>\n</li>\n<li>\n<p><a href=\"#toc_185\">添加一些用户数据</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_186\">发布一个插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_187\">创建 flash 插件</a></p>\n<pre class=\"prettyprint\"><code>*   [初始化项目](#toc_188)\n\n    *   [安装依赖](#toc_189)\n\n    *   [修改插件名字与依赖](#toc_190)\n\n    *   [修改测试里面的逻辑](#toc_191)\n\n        *   [安装依赖](#toc_192)\n\n            *   [开启插件](#toc_193)\n\n            *   [修改 controller&#x2F;home.js](#toc_194)\n\n            *   [修改 router.js](#toc_195)\n\n    *   [小小的测试一下](#toc_196)\n\n    *   [创建 app&#x2F;middleware&#x2F;flash.js](#toc_197)\n\n    *   [把这个中间件插入到 session 之后](#toc_198)\n\n    *   [查看代码测试覆盖率](#toc_199)\n\n    *   [更新 README.md](#toc_200)\n\n    *   [提交到仓库](#toc_201)\n\n    *   [发布到 npmjs](#toc_202)\n\n    *   [上传测试覆盖率](#toc_203)\n\n    *   [测试 CI 是否成功](#toc_204)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_205\">使用 egg-msg-flash</a></p>\n</li>\n<li>\n<p><a href=\"#toc_206\">使用 egg-y-validator</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_207\">规范化</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_208\">添加新的 scripts 支持 ESLint 自修复</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_209\">添加插件支持</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_210\">安装</a></p>\n<ul>\n<li><a href=\"#toc_211\">如何解决错误</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_212\">prettier 格式化工具</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_213\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_214\">VSCode 的配置</a></p>\n</li>\n<li>\n<p><a href=\"#toc_215\">创建 .prettierrc</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_216\">同步代码编辑器配置</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_217\">第一个 JSON 请求</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_218\">给全局添加一些方法</a></p>\n<pre class=\"prettyprint\"><code>*   [添加代码](#toc_219)\n\n    *   [函数柯里化](#toc_220)\n\n    *   [check 函数](#toc_221)\n\n    *   [函数组合](#toc_222)\n\n    *   [添加方法](#toc_223)\n\n    *   [装载辅助方法](#toc_224)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_225\">全局化一些东西</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_226\">创建 BaseContrller</a></p>\n<ul>\n<li><a href=\"#toc_227\">测试一下 use</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_228\">自动路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_229\">新建 app/api.js</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_230\">新建 app/utils.js</a></p>\n</li>\n<li>\n<p><a href=\"#toc_231\">新建 app/contrller/user.js</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_232\">创建 PostMan 测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_233\">安装 PostMan</a></p>\n<ul>\n<li><a href=\"#toc_234\">解决 CSRF 问题</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_235\">注册服务</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_236\">Invitation 模型</a></p>\n<pre class=\"prettyprint\"><code>*   [安装依赖](#toc_237)\n\n    *   [添加逻辑](#toc_238)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_239\">注释</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_240\">安装插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_241\">查找 TODO</a></p>\n</li>\n<li>\n<p><a href=\"#toc_242\">方法注释</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_243\">User 模型</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_244\">安装依赖</a></p>\n<ul>\n<li><a href=\"#toc_245\">添加逻辑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_246\">修改控制器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_247\">添加验证逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_248\">帮助方法</a></p>\n</li>\n<li>\n<p><a href=\"#toc_249\">User 服务</a></p>\n</li>\n<li>\n<p><a href=\"#toc_250\">PostMan 测试</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_251\">登陆服务</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_252\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_253\">添加环境变量判断</a></p>\n</li>\n<li>\n<p><a href=\"#toc_254\">开启插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_255\">自动函数</a></p>\n</li>\n<li>\n<p><a href=\"#toc_256\">路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_257\">添加 passport 逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_258\">添加本地验证逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_259\">表单验证逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_260\">验证</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_261\">邮件与调试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_262\">理解发送邮件的原理</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_263\">安装邮件插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_264\">环境与调试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_265\">添加全局方法</a></p>\n<ul>\n<li><a href=\"#toc_266\">修改之前的调试方式</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_267\">全局调试</a></p>\n</li>\n<li>\n<p><a href=\"#toc_268\">VSCode 全局调试</a></p>\n</li>\n<li>\n<p><a href=\"#toc_269\">发送验证邮件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_270\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_271\">为 VSCode 添加 nunjucks 代码片段</a></p>\n</li>\n<li>\n<p><a href=\"#toc_272\">安装 redis</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_273\">添加逻辑</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_274\">service</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_275\">扩展</a></p>\n</li>\n<li>\n<p><a href=\"#toc_276\">控制器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_277\">验证</a></p>\n</li>\n<li>\n<p><a href=\"#toc_278\">添加视图</a></p>\n</li>\n<li>\n<p><a href=\"#toc_279\">路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_280\">兼容方案</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_281\">验证</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_282\">注册用户</a></p>\n<ul>\n<li><a href=\"#toc_283\">找回密码功能</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_284\">构建 RESTful API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_285\">什么是 RESTful API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_286\">创建 RESTContrller 基础类便于继承</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_287\">创建 app/controller/rest.js</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_288\">app/controller/image.js</a></p>\n</li>\n<li>\n<p><a href=\"#toc_289\">注册路由</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_290\">测试 Images RESTful API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_291\">POST 创建</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_292\">DELETE 删除</a></p>\n</li>\n<li>\n<p><a href=\"#toc_293\">GET 列表</a></p>\n</li>\n<li>\n<p><a href=\"#toc_294\">GET 单个数据</a></p>\n</li>\n<li>\n<p><a href=\"#toc_295\">PUT 修改</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_296\">构建后台的 REST 路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_297\">构建简单的 HTTP 验证</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_298\">构建 http auth 的路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_299\">构建控制器</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_300\">app/controller/all.js</a></p>\n<ul>\n<li><a href=\"#toc_301\">app/controller/admin.js</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_302\">测试后台路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_303\">关于验证</a></p>\n<ul>\n<li><a href=\"#toc_304\">小小的测试一下</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_305\">安全的开放 API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_306\">了解 OAuth 2.0</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_307\">授权码登录的流程</a></p>\n</li>\n<li>\n<p><a href=\"#toc_308\">实现数据结构表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_309\">生成 Client Model</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_310\">修改 Client Model</a></p>\n</li>\n<li>\n<p><a href=\"#toc_311\">生成 Authorization Model</a></p>\n</li>\n<li>\n<p><a href=\"#toc_312\">修改 Authorization Model</a></p>\n</li>\n<li>\n<p><a href=\"#toc_313\">创建 Access</a></p>\n</li>\n<li>\n<p><a href=\"#toc_314\">修改 Access 模型</a></p>\n</li>\n<li>\n<p><a href=\"#toc_315\">创建 Refresh</a></p>\n</li>\n<li>\n<p><a href=\"#toc_316\">修改 Refresh 模型</a></p>\n</li>\n<li>\n<p><a href=\"#toc_317\">创建表</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_318\">安装插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_319\">开启插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_320\">配置插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_321\">创建实现接口</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_322\">实现 OAuth 接口</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_323\">实现授权码官方文档所要求接口</a></p>\n<pre class=\"prettyprint\"><code>*   [实现 getAuthorizationCode](#toc_324)\n\n        *   [官方实现的版本](#toc_325)\n\n            *   [我们实现的版本](#toc_326)\n\n    *   [实现 getClient](#toc_327)\n\n        *   [官方实现的版本](#toc_328)\n\n            *   [我们实现的版本](#toc_329)\n\n    *   [实现 saveToken](#toc_330)\n\n        *   [官方实现的版本](#toc_331)\n\n            *   [我们实现的版本](#toc_332)\n\n    *   [实现 saveAuthorizationCode](#toc_333)\n\n        *   [官方实现的版本](#toc_334)\n\n            *   [我们实现的版本](#toc_335)\n\n    *   [实现 revokeAuthorizationCode](#toc_336)\n\n        *   [官方实现的版本](#toc_337)\n\n            *   [我们实现的版本](#toc_338)\n\n    *   [实现 validateScope](#toc_339)\n\n        *   [官方实现的版本](#toc_340)\n\n            *   [我们实现的版本](#toc_341)\n\n    *   [实现 verifyScope](#toc_342)\n\n        *   [官方实现的版本](#toc_343)\n\n            *   [我们实现的版本](#toc_344)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_345\">实现刷新验证码接口</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_346\">实现 getRefreshToken</a></p>\n<pre class=\"prettyprint\"><code>*   [官方实现的版本](#toc_347)\n\n    *   [我们实现的版本](#toc_348)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_349\">实现 revokeToken</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_350\">官方实现的版本</a></p>\n<ul>\n<li><a href=\"#toc_351\">我们实现的版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_352\">实现用户认证</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_353\">官方实现的版本</a></p>\n<ul>\n<li><a href=\"#toc_354\">我们实现的版本</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_355\">实现 authenticate 所需接口</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_356\">实现 getAccessToken</a></p>\n<pre class=\"prettyprint\"><code>*   [官方实现的版本](#toc_357)\n\n    *   [我们实现的版本](#toc_358)\n</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_359\">完善 OAuth 与测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_360\">发放 Token</a></p>\n<pre class=\"prettyprint\"><code>*   [暂时关闭 jwt](#toc_361)\n\n    *   [添加路由](#toc_362)\n\n    *   [修改 home 控制器](#toc_363)\n\n    *   [添加视图](#toc_364)\n\n    *   [添加数据](#toc_365)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_366\">新建客户端项目</a></p>\n</li>\n<li>\n<p><a href=\"#toc_367\">测试 OAuth</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_368\">访问 localhost:7002</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_369\">自动跳转</a></p>\n</li>\n<li>\n<p><a href=\"#toc_370\">PostMan 测试所保护的接口</a></p>\n</li>\n<li>\n<p><a href=\"#toc_371\">添加 scope</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_372\">支付宝支付</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_373\">什么是非对称加密</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_374\">注册支付宝</a></p>\n</li>\n<li>\n<p><a href=\"#toc_375\">生成非对称秘钥</a></p>\n</li>\n<li>\n<p><a href=\"#toc_376\">实现</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_377\">添加配置</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_378\">扩展 context</a></p>\n</li>\n<li>\n<p><a href=\"#toc_379\">创建 Pay 控制器</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_380\">添加路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_381\">内网穿透</a></p>\n</li>\n<li>\n<p><a href=\"#toc_382\">测试</a></p>\n<ul>\n<li><a href=\"#toc_383\">访问支付页面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_384\">社会化登陆</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_385\">创建记录表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_386\">修改 migration</a></p>\n</li>\n<li>\n<p><a href=\"#toc_387\">model</a></p>\n</li>\n<li>\n<p><a href=\"#toc_388\">同步到数据库表中</a></p>\n</li>\n<li>\n<p><a href=\"#toc_389\">安装插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_390\">配置路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_391\">添加逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_392\">测试</a></p>\n</li>\n<li>\n<p><a href=\"#toc_393\">开启 jwt</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_394\">开始后端</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_395\">安装 VSCode 插件</a></p>\n<pre class=\"prettyprint\"><code>*   [如何打开调试？](#toc_396)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_397\">获取脚手架</a></p>\n</li>\n<li>\n<p><a href=\"#toc_398\">安装依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_399\">修改代码</a></p>\n<ul>\n<li><a href=\"#toc_400\">添加主题样式</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_401\">跨域请求</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_402\">什么是跨域。</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_403\">怎样解决跨域呢？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_404\">JSONP</a></p>\n<ul>\n<li><a href=\"#toc_405\">CORS</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_406\">修改后端代码支持跨域</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_407\">安装 egg-cors</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_408\">添加 jsonp 支持</a></p>\n</li>\n<li>\n<p><a href=\"#toc_409\">添加计算表数据的 api</a></p>\n</li>\n<li>\n<p><a href=\"#toc_410\">修改前端的代码</a></p>\n</li>\n<li>\n<p><a href=\"#toc_411\">启动前端的服务</a></p>\n</li>\n<li>\n<p><a href=\"#toc_412\">添加一下获取后端表结构的路由</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_413\">在前端添加存储</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_414\">修改 client/api.js</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_415\">修改 store/index.js</a></p>\n</li>\n<li>\n<p><a href=\"#toc_416\">修改 views/home.vue</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_417\">模型列表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_418\">修改后台查询接口</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_419\">修改 .eslintrc.json</a></p>\n</li>\n<li>\n<p><a href=\"#toc_420\">添加帮助方法</a></p>\n</li>\n<li>\n<p><a href=\"#toc_421\">在入口添加载入数据逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_422\">修改样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_423\">创建视图工厂</a></p>\n<ul>\n<li><a href=\"#toc_424\">创建视图模板</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_425\">添加获取数据方法</a></p>\n</li>\n<li>\n<p><a href=\"#toc_426\">在首页添加一些链接</a></p>\n</li>\n<li>\n<p><a href=\"#toc_427\">删除原有的样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_428\">测试一下页面</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_429\">添加数据</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_430\">jsx 语法</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_431\">安装依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_432\">初始化插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_433\">创建显示名字映射</a></p>\n</li>\n<li>\n<p><a href=\"#toc_434\">新建 VForm 组件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_435\">测试</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_436\">修改逻辑</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_437\">添加图标</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_438\">添加 API 接口</a></p>\n</li>\n<li>\n<p><a href=\"#toc_439\">修改视图</a></p>\n</li>\n<li>\n<p><a href=\"#toc_440\">修改静态框逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_441\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_442\">修改</a></p>\n<ul>\n<li><a href=\"#toc_443\">删除</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_444\">构建</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_445\">开始构建</a></p>\n<ul>\n<li><a href=\"#toc_446\">配置后台</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_447\">小结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_448\">搭建前端开发环境</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_449\">开始</a></p>\n<pre class=\"prettyprint\"><code>*   [安装依赖](#toc_450)\n\n    *   [删除缓存](#toc_451)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_452\">创建 Header 头部</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_453\">安装样式依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_454\">创建文件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_455\">添加移动端效果</a></p>\n</li>\n<li>\n<p><a href=\"#toc_456\">实现生命周期函数钩子？</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_457\">将变量提取出来</a></p>\n</li>\n<li>\n<p><a href=\"#toc_458\">添加路径重写</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_459\">AppFooter 组件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_460\">做一些配置</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_461\">创建 src/components/layouts/AppFooter.vue</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_462\">添加图标文件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_463\">第一栏</a></p>\n</li>\n<li>\n<p><a href=\"#toc_464\">第二列</a></p>\n</li>\n<li>\n<p><a href=\"#toc_465\">第三列</a></p>\n</li>\n<li>\n<p><a href=\"#toc_466\">第四列</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_467\">网络识别信息</a></p>\n</li>\n<li>\n<p><a href=\"#toc_468\">修改一下全局样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_469\">查看页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_470\">提升一下编译速度</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_471\">首页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_472\">配置</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_473\">安装依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_474\">创建 src/views/index.vue</a></p>\n</li>\n<li>\n<p><a href=\"#toc_475\">异步加载</a></p>\n</li>\n<li>\n<p><a href=\"#toc_476\">新建 api 目录</a></p>\n</li>\n<li>\n<p><a href=\"#toc_477\">开启插件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_478\">新建数据存储器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_479\">为什么需要数据存储器 store ?</a></p>\n</li>\n<li>\n<p><a href=\"#toc_480\">修改 index.vue</a></p>\n</li>\n<li>\n<p><a href=\"#toc_481\">效果</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_482\">在移动端的效果</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_483\">没有更多的效果</a></p>\n</li>\n<li>\n<p><a href=\"#toc_484\">多列模式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_485\">大图模式</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_486\">替换成为真实数据</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_487\">完成后端 Image API</a></p>\n<pre class=\"prettyprint\"><code>*   [添加控制器](#toc_488)\n\n    *   [注册路由](#toc_489)\n\n    *   [用 PostMan 测试一下](#toc_490)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_491\">修改首页的代码</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_492\">页面逻辑</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_493\">添加样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_494\">添加模板</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_495\">添加 API 逻辑</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_496\">新建 api/v1/common.ts</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_497\">混合</a></p>\n</li>\n<li>\n<p><a href=\"#toc_498\">修改 store/index</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_499\">效果</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_500\">桌面端</a></p>\n<ul>\n<li><a href=\"#toc_501\">移动端</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_502\">图片详情页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_503\">创建路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_504\">安装依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_505\">创建视图</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_506\">添加样式</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_507\">添加逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_508\">添加模板</a></p>\n</li>\n<li>\n<p><a href=\"#toc_509\">组件样式</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_510\">添加插件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_511\">修改 src/app.sass</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_512\">修改 src/plugin.ts</a></p>\n</li>\n<li>\n<p><a href=\"#toc_513\">Hack DOM</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_514\">创建评论组件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_515\">新建模板</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_516\">新建 AppComment.vue</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_517\">添加模板</a></p>\n<ul>\n<li><a href=\"#toc_518\">添加逻辑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_519\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_520\">默认情况</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_521\">点击评论数</a></p>\n</li>\n<li>\n<p><a href=\"#toc_522\">显示评论框</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_523\">关于服务端访问 DOM</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_524\">把访问 DOM 的逻辑放在 mounted 或 beforeMount 里面去</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_525\">尽量尝试使用源码 vue 组件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_526\">使用指令</a></p>\n</li>\n<li>\n<p><a href=\"#toc_527\">vue-quill-editor/src/ssr.js 是否真正的运行在服务端</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_528\">注册页面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_529\">注册路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_530\">新建 signup.vue 页面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_531\">添加模板</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_532\">添加样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_533\">添加 API</a></p>\n</li>\n<li>\n<p><a href=\"#toc_534\">添加逻辑</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_535\">增强错误提示</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_536\">登陆页面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_537\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_538\">添加路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_539\">页面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_540\">模板</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_541\">样式</a></p>\n</li>\n<li>\n<p><a href=\"#toc_542\">页面逻辑</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_543\">载入用户 token</a></p>\n</li>\n<li>\n<p><a href=\"#toc_544\">添加发送请求 API</a></p>\n</li>\n<li>\n<p><a href=\"#toc_545\">添加全局状态</a></p>\n</li>\n<li>\n<p><a href=\"#toc_546\">修改菜单栏</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_547\">模板</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_548\">退出逻辑</a></p>\n</li>\n<li>\n<p><a href=\"#toc_549\">映射全局状态</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_550\">社会化登陆</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_551\">启动内网穿透</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_552\">更新网址</a></p>\n</li>\n<li>\n<p><a href=\"#toc_553\">修改视图的链接</a></p>\n</li>\n<li>\n<p><a href=\"#toc_554\">修改后端 jwt</a></p>\n</li>\n<li>\n<p><a href=\"#toc_555\">修改重定向地址</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_556\">配置 frontURL</a></p>\n<ul>\n<li><a href=\"#toc_557\">修改 app/passport/github.js</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_558\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_559\">Github 登陆</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_560\">普通登陆</a></p>\n</li>\n<li>\n<p><a href=\"#toc_561\">输入错误的情况</a></p>\n</li>\n<li>\n<p><a href=\"#toc_562\">输入正确的情况</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_563\">升级方案</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_564\">方案一</a></p>\n<ul>\n<li><a href=\"#toc_565\">方案二</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_566\">完善详情与评论</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_567\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_568\">添加全局 filter</a></p>\n</li>\n<li>\n<p><a href=\"#toc_569\">添加后端逻辑</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_570\">添加 API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_571\">创建 comment 控制器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_572\">为 image 控制器添加 show 方法</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_573\">添加 SPA API 方法</a></p>\n</li>\n<li>\n<p><a href=\"#toc_574\">修改 store 存储</a></p>\n</li>\n<li>\n<p><a href=\"#toc_575\">修改首页视图</a></p>\n</li>\n<li>\n<p><a href=\"#toc_576\">修改详情视图</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_577\">模板</a></p>\n<ul>\n<li><a href=\"#toc_578\">逻辑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_579\">修改评论组件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_580\">模板</a></p>\n<ul>\n<li><a href=\"#toc_581\">逻辑</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_582\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_583\">详情评论</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_584\">画廊功能</a></p>\n</li>\n<li>\n<p><a href=\"#toc_585\">提交评论</a></p>\n</li>\n<li>\n<p><a href=\"#toc_586\">at 功能</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_587\">个人中心</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_588\">解决一些 Bug</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_589\">重构一些代码</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_590\">视图名称</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_591\">用户信息盒子组件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_592\">图片组件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_593\">图片 DOM 组件</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_594\">个人中心首页</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_595\">新建 views/me.vue</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_596\">创建 views/me 文件夹</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_597\">left-menu.vue</a></p>\n<ul>\n<li><a href=\"#toc_598\">index.vue</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_599\">个人中心邀请码页</a></p>\n<ul>\n<li><a href=\"#toc_600\">新建 view/me/invitation.vue</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_601\">添加路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_602\">完善 API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_603\">修改 api/v1/client/index.ts</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_604\">修改后端 api</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_605\">先在 app/api.js 里面添加路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_606\">修改 app/controller/image.js</a></p>\n</li>\n<li>\n<p><a href=\"#toc_607\">新建 app/controller/invitation.js</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_608\">测试一下</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_609\">个人中心首页</a></p>\n<ul>\n<li><a href=\"#toc_610\">个人中心邀请码页</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_611\">创建图片</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_612\">创建又拍云存储</a></p>\n<pre class=\"prettyprint\"><code>*   [安装 SDK](#toc_613)\n\n    *   [后端配置](#toc_614)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_615\">添加后端 api</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_616\">创建路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_617\">添加控制器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_618\">如何存储图片？</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_619\">前端界面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_620\">添加前端 API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_621\">添加路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_622\">创建页面</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_623\">添加样式</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_624\">添加模板</a></p>\n</li>\n<li>\n<p><a href=\"#toc_625\">添加逻辑</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_626\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_627\">将图片拖入选项框中</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_628\">删除图片</a></p>\n</li>\n<li>\n<p><a href=\"#toc_629\">点击上传图片按钮</a></p>\n</li>\n<li>\n<p><a href=\"#toc_630\">查看服务里面是否上传完成</a></p>\n</li>\n<li>\n<p><a href=\"#toc_631\">提交数据</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_632\">团队</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_633\">功能是如何工作的？</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_634\">数据库</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_635\">给 Team 添加 lock 字段</a></p>\n<pre class=\"prettyprint\"><code>*   [命令](#toc_636)\n\n    *   [up 方法](#toc_637)\n\n    *   [down 方法](#toc_638)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_639\">角色表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_640\">命令</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_641\">Migration</a></p>\n</li>\n<li>\n<p><a href=\"#toc_642\">Model</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_643\">权限表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_644\">命令</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_645\">Migration</a></p>\n</li>\n<li>\n<p><a href=\"#toc_646\">Model</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_647\">用户角色关联表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_648\">命令</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_649\">Migration</a></p>\n</li>\n<li>\n<p><a href=\"#toc_650\">Model</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_651\">角色权限关联表</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_652\">命令</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_653\">Migration</a></p>\n</li>\n<li>\n<p><a href=\"#toc_654\">Model</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_655\">修正 Team 的关联关系</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_656\">后端</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_657\">添加后端路由</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_658\">添加 Team 控制器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_659\">团队动态</a></p>\n</li>\n<li>\n<p><a href=\"#toc_660\">检测团队是否过期</a></p>\n</li>\n<li>\n<p><a href=\"#toc_661\">修改支付成功重定向地址</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_662\">前端</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_663\">添加前端 API</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_664\">添加路由</a></p>\n</li>\n<li>\n<p><a href=\"#toc_665\">导入页面</a></p>\n</li>\n<li>\n<p><a href=\"#toc_666\">路由配置</a></p>\n</li>\n<li>\n<p><a href=\"#toc_667\">团队页</a></p>\n</li>\n<li>\n<p><a href=\"#toc_668\">创建页</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_669\">测试</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_670\">创建团队</a></p>\n<ul>\n<li><a href=\"#toc_671\">添加成员</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_672\">认识 Docker</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_673\">解决了什么问题？</a></p>\n<pre class=\"prettyprint\"><code>*   [频繁搭建环境](#toc_674)\n\n    *   [环境不一致](#toc_675)\n\n    *   [二次虚拟化](#toc_676)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_677\">使用 Docker 的流程</a></p>\n</li>\n<li>\n<p><a href=\"#toc_678\">安装 Docker</a></p>\n</li>\n<li>\n<p><a href=\"#toc_679\">使用加速器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_680\">下载一个基础镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_681\">hello world</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_682\">手动构建镜像</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_683\">Docker 架构</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_684\">学习使用命令行</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_685\">查看已有的镜像</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_686\">下载镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_687\">删除镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_688\">运行镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_689\">查看所有容器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_690\">将修改好的容器提交为镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_691\">登陆镜像中心</a></p>\n</li>\n<li>\n<p><a href=\"#toc_692\">创建镜像副本</a></p>\n</li>\n<li>\n<p><a href=\"#toc_693\">推送镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_694\">如何搭建私有的镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_695\">删除一个容器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_696\">停止运行一个容器</a></p>\n</li>\n<li>\n<p><a href=\"#toc_697\">重启并重新接管 shell</a></p>\n</li>\n<li>\n<p><a href=\"#toc_698\">让运行的容器再开一个 shell</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_699\">总结</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_700\">编写 Dockerfile 文件</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_701\">如何从 Dockerfile 构建镜像</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_702\">FROM 指令</a></p>\n</li>\n<li>\n<p><a href=\"#toc_703\">RUN 命令</a></p>\n</li>\n<li>\n<p><a href=\"#toc_704\">CMD 与 ENTRYPOINT 命令</a></p>\n</li>\n<li>\n<p><a href=\"#toc_705\">VOLUME 指令</a></p>\n</li>\n<li>\n<p><a href=\"#toc_706\">COPY 与 ADD</a></p>\n</li>\n<li>\n<p><a href=\"#toc_707\">EXPORT</a></p>\n</li>\n<li>\n<p><a href=\"#toc_708\">WORKDIR</a></p>\n</li>\n<li>\n<p><a href=\"#toc_709\">运行一个 Server 实例</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_710\">Docker Compose</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_711\">安装 docker-compose</a></p>\n<pre class=\"prettyprint\"><code>*   [pip 安装](#toc_712)\n\n    *   [手动下载](#toc_713)\n</code></pre><ul>\n<li>\n<p><a href=\"#toc_714\">命令行接口</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_715\">build</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_716\">up</a></p>\n</li>\n<li>\n<p><a href=\"#toc_717\">logs</a></p>\n</li>\n<li>\n<p><a href=\"#toc_718\">down</a></p>\n</li>\n<li>\n<p><a href=\"#toc_719\">ps</a></p>\n</li>\n<li>\n<p><a href=\"#toc_720\">stop</a></p>\n</li>\n<li>\n<p><a href=\"#toc_721\">start</a></p>\n</li>\n<li>\n<p><a href=\"#toc_722\">restart</a></p>\n</li>\n<li>\n<p><a href=\"#toc_723\">exec</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_724\">egg.js 简单实例</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_725\">先初始化项目</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_726\">安装依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_727\">创建 Dockerfile</a></p>\n</li>\n<li>\n<p><a href=\"#toc_728\">创建 docker-compose.yml</a></p>\n</li>\n<li>\n<p><a href=\"#toc_729\">构建镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_730\">启动</a></p>\n</li>\n<li>\n<p><a href=\"#toc_731\">测试一下</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_732\">增加服务</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_733\">安装依赖</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_734\">开启依赖</a></p>\n</li>\n<li>\n<p><a href=\"#toc_735\">修改 docker-compose.yml</a></p>\n</li>\n<li>\n<p><a href=\"#toc_736\">启动</a></p>\n</li>\n<li>\n<p><a href=\"#toc_737\">确认数据是否持久化</a></p>\n</li>\n<li>\n<p><a href=\"#toc_738\">数据库迁移</a></p>\n</li>\n<li>\n<p><a href=\"#toc_739\">清空</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_740\">集群</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_741\">Docker 集群</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_742\">集群初始化</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_743\">初始化主节点</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_744\">连接主节点</a></p>\n</li>\n<li>\n<p><a href=\"#toc_745\">在集群里面部署应用</a></p>\n</li>\n<li>\n<p><a href=\"#toc_746\">查看运行的应用</a></p>\n</li>\n<li>\n<p><a href=\"#toc_747\">删除应用</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_748\">docker-compose.yml</a></p>\n</li>\n<li>\n<p><a href=\"#toc_749\">实例</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_750\">添加代码</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_751\">添加配置</a></p>\n</li>\n<li>\n<p><a href=\"#toc_752\">初始化节点</a></p>\n</li>\n<li>\n<p><a href=\"#toc_753\">构建镜像</a></p>\n</li>\n<li>\n<p><a href=\"#toc_754\">运行</a></p>\n</li>\n<li>\n<p><a href=\"#toc_755\">查看服务</a></p>\n</li>\n<li>\n<p><a href=\"#toc_756\">访问 web</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_757\">持续部署</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_758\">部署主机免密码登陆</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_759\">客户端钩子</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_760\">搭建项目环境</a></p>\n<ul>\n<li><a href=\"#toc_761\">初始化仓库</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_762\">使用服务端钩子部署</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_763\">初始化服务器仓库</a></p>\n<ul>\n<li><a href=\"#toc_764\">初始化本地仓库</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_765\">使用 shipit</a></p>\n<ul>\n<li><a href=\"#toc_766\">安装依赖</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_767\">使用 ansible 部署</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_768\">安装</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_769\">搭建环境</a></p>\n</li>\n<li>\n<p><a href=\"#toc_770\">运行命令执行脚本</a></p>\n</li>\n<li>\n<p><a href=\"#toc_771\">pm2 错误</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_772\">持续集成</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_773\">创建 Docker 镜像服务</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_774\">创建仓库</a></p>\n</li>\n<li>\n<p><a href=\"#toc_775\">修改</a></p>\n</li>\n<li>\n<p><a href=\"#toc_776\">本地测试一下</a></p>\n</li>\n<li>\n<p><a href=\"#toc_777\">让腾讯云帮我们构建</a></p>\n</li>\n<li>\n<p><a href=\"#toc_778\">创建工作流水线</a></p>\n</li>\n<li>\n<p><a href=\"#toc_779\">部署</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_780\">kubernetes 集群</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_781\">简单使用</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_782\">如何创建应用？</a></p>\n</li>\n<li>\n<p><a href=\"#toc_783\">命令行管理</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_784\">下载 kompose</a></p>\n<ul>\n<li>\n<p><a href=\"#toc_785\">转换文件</a></p>\n</li>\n<li>\n<p><a href=\"#toc_786\">创建集群</a></p>\n</li>\n<li>\n<p><a href=\"#toc_787\">安装管理工具</a></p>\n</li>\n<li>\n<p><a href=\"#toc_788\">尝试 Kompose</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#toc_789\">通过 UI 创建应用</a></p>\n</li>\n<li>\n<p><a href=\"#toc_790\">添加持续集成</a></p>\n</li>\n<li>\n<p><a href=\"#toc_791\">固定 IP</a></p>\n</li>\n<li>\n<p><a href=\"#toc_792\">部署前端</a></p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>",
      "title": "《Node.js实战：使用Egg.js + Vue.js + Docker构建渐进式、可持续集成与交付应用》 新书预热。",
      "last_reply_at": "2018-08-31T07:45:23.727Z",
      "good": false,
      "top": false,
      "reply_count": 56,
      "visit_count": 9274,
      "create_at": "2018-05-02T03:48:32.085Z",
      "author": {
        "loginname": "MiYogurt",
        "avatar_url": "https://avatars3.githubusercontent.com/u/10082395?v=4&s=120"
      }
    },
    {
      "id": "5b84d3752a585e4e2f26ff5b",
      "author_id": "5b804123a210553a0cde2bfc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1>每天阅读一个 npm 模块（3）- mimic-fn</h1>\n<p>系列文章：</p>\n<ol>\n<li><a href=\"https://cnodejs.org/topic/5b8041eec52ad1482eb941ce\">每天阅读一个 npm 模块（1）- username</a></li>\n<li><a href=\"https://cnodejs.org/topic/5b82dd11632c7f422e5b815a\">每天阅读一个 npm 模块（2）- mem</a></li>\n</ol>\n<p>昨天阅读 <a href=\"https://www.npmjs.com/package/mem\">mem</a> 的源码之后，提出了当参数为 RegExp 类型时，运行结果会存在问题。今天又仔细思考了一下，对于 Symbol 类型，也会存在同样的问题。通过 <a href=\"https://github.com/sindresorhus/mem/issues/20\">mem - Issue #20</a> 和作者 Sindre Sorhus 讨论之后，已经得出了初步的解决方法，相信这个 bug 会在最近被 fix 😊</p>\n<h2>一句话介绍</h2>\n<p>今天阅读的 npm 模块是 <a href=\"https://www.npmjs.com/package/mimic-fn\">mimic-fn</a>，mimic 的意思是模仿，它通过对原函数的复制从而模仿原函数的行为，可以在不修改原函数的前提下，扩充函数的功能，当前版本为 1.2.0，周下载量约为 421 万。</p>\n<h2>用法</h2>\n<pre class=\"prettyprint language-javascript\"><code>const mimicFn = require(&#x27;mimic-fn&#x27;);\n\nfunction foo() {}\nfoo.date = &#x27;2018-08-27&#x27;;\n\nfunction wrapper() {\n\treturn foo() {};\n}\n\nconsole.log(wrapper.name);\n&#x2F;&#x2F;=&gt; &#x27;wrapper&#x27;\n\n&#x2F;&#x2F; 此处复制 foo 函数后，\n&#x2F;&#x2F; foo 拥有的功能，wrapper 均有\nmimicFn(wrapper, foo);\n\nconsole.log(wrapper.name);\n&#x2F;&#x2F;=&gt; &#x27;foo&#x27;\n\nconsole.log(wrapper.date);\n&#x2F;&#x2F;=&gt; &#x27;2018-08-27&#x27;\n</code></pre><h2>源码学习</h2>\n<p>实现 <a href=\"https://www.npmjs.com/package/mimic-fn\">mimic-fn</a> 功能的难点在于如何获得原函数所有的属性并将其赋值给新函数。其实源码非常非常非常（重要的事情说三遍）短：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源码 3-1\nmodule.exports = (to, from) =&gt; {\n\tfor (const prop of Object.getOwnPropertyNames(from).concat(Object.getOwnPropertySymbols(from))) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n</code></pre><p>虽然源码只有四五行，但是涉及 JavaScript 中非常核心基础的内容 —— <code>property descriptor</code>（属性描述符），还是值得好好研究一下的。</p>\n<h3>属性描述符介绍</h3>\n<p>形如 <code>const obj = {x: 1}</code> 是最简单的对象，<code>x</code> 是 <code>obj</code> 的一个属性。ES5 带给了我们对属性 <code>x</code> 进行定制化的能力。通过 <code>Object.defineProperty(obj, 'x', descriptor)</code> 可以实现一些有意思的效果：</p>\n<h4>不能被修改的属性</h4>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\n\n&#x2F;&#x2F; 定于不能被修改的 x 属性\nObject.defineProperty(obj, &#x27;x&#x27;, {\n   value: 1,\n   writable: false,\n});\n\nconsole.log(obj.x);\n&#x2F;&#x2F; =&gt; 1\n\nobj.x = 2;\nconsole.log(obj.x);\n&#x2F;&#x2F; =&gt; 1\n</code></pre><h4>不能被删除的属性</h4>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\n\n&#x2F;&#x2F; 定义不能被删除的 y 属性\nObject.defineProperty(obj, &#x27;y&#x27;, {\n    value: 1,\n    configurable: false,\n});\n\nconsole.log(obj.y);\n&#x2F;&#x2F; =&gt; 1\n\nconsole.log(delete obj.y);\n&#x2F;&#x2F; =&gt; false\n\nconsole.log(obj.y);\n&#x2F;&#x2F; =&gt; 1\n</code></pre><h4>不能被遍历的属性</h4>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\n\n&#x2F;&#x2F; 定义不能被遍历的 z 属性\nObject.defineProperty(obj, &#x27;z&#x27;, {\n    value: 1,\n    enumerable: false,\n});\n\nconsole.log(obj, obj.z);\n&#x2F;&#x2F; =&gt; {}, 1\n\nfor (const key in obj) {\n    console.log(key, obj[key]);\n}\n&#x2F;&#x2F; =&gt; 没有输出\n</code></pre><h4>输入与输出不同的属性</h4>\n<pre class=\"prettyprint language-javascript\"><code>const obj = {};\n\n&#x2F;&#x2F; 定义输入与输出不同的 u 属性\nObject.defineProperty(obj, &#x27;u&#x27;, {\n    get: function() {\n        return this._u * 2;\n    },\n    set: function(value) {\n        this._u = value;\n    },\n});\n\nobj.u = 1;\nconsole.log(obj.u);\n&#x2F;&#x2F; =&gt; 2\n\n</code></pre><p>从上面的例子中可以了解到通过属性描述符的 value | writable | configurable | enumerable | set | get 字段可以实现神奇的效果，相信它们的含义大家也能猜出来，下面的介绍摘自 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\">MDN - Object.defineProperty()</a>：</p>\n<ul>\n<li>configurable：当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</li>\n<li>enumerable：当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</li>\n<li>value：该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。</li>\n<li>writable：当且仅当该属性的 writable 为 true 时，value 才能被赋值运算符改变。默认为 false。</li>\n<li>get：一个给属性提供 getter 的方法，如果没有 getter 则为 <code>undefined</code>。</li>\n<li>set：一个给属性提供 setter 的方法，如果没有 setter 则为 <code>undefined</code>。当属性值修改时，触发执行该方法。该方法将接受唯一参数，即该属性新的参数值。</li>\n</ul>\n<p>需要注意的是，属性描述符分为两类：</p>\n<ul>\n<li>数据描述符（data descriptor）：可设置 configurable | enumerable |value | writable。</li>\n<li>存储描述符（access descriptor）：可设置 configurable | enumerable | get | set。</li>\n</ul>\n<p>可以看出，一个属性不可能同时设置 value 和 get 或者同时设置 writable 和 set 等。</p>\n<p>对于我们最常用的对象自变量 <code>const obj = {x: 1}</code> 的属性 x，其属性描述符的值为：</p>\n<pre class=\"prettyprint language-js\"><code>{ \n\tvalue: 1,\n\twritable: true,\n\tenumerable: true,\n\tconfigurable: true,\n}\n</code></pre><h3>函数的属性描述符</h3>\n<p>众所周知在 JavaScript 中一切皆对象，所以函数也有自己的属性描述符，通过 <code>Object.getOwnPropertyDescriptors()</code> 来看看对于一个已定义的函数，其具有哪些属性：</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) { \n    console.log(&#x27;foo..&#x27;); \n}\n\nconsole.log(Object.getOwnPropertyDescriptors(foo));\n\n{ \n   length:\n   { value: 1,\n     writable: false,\n     enumerable: false,\n     configurable: true },\n  name:\n   { value: &#x27;foo&#x27;,\n     writable: false,\n     enumerable: false,\n     configurable: true },\n  arguments:\n   { value: null,\n     writable: false,\n     enumerable: false,\n     configurable: false },\n  caller:\n   { value: null,\n     writable: false,\n     enumerable: false,\n     configurable: false },\n  prototype:\n   { value: foo {},\n     writable: true,\n     enumerable: false,\n     configurable: false }\n}\n</code></pre><p>从上面的代码中可以看出函数一共有 5 个属性，分别为：</p>\n<ol>\n<li>\n<p>length：函数定义的参数个数。</p>\n</li>\n<li>\n<p>name：函数名，注意其 <code>writable</code> 为 false，所以直接改变函数名 <code>foo.name = bar</code> 是不起作用的。</p>\n</li>\n<li>\n<p>arguments：函数<strong>执行时</strong>的参数，是一个类数组，在 ‘use strict’ 严格模式下无法使用。对于 ES6+，可以通过 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters\">Rest Parameters</a> 实现同样的功能，而且在严格模式下仍能使用。</p>\n<pre class=\"prettyprint language-javascript\"><code>function foo(x) { \n    console.log(&#x27;foo..&#x27;, arguments);\n}\n\nfunction bar(...rest) {\n    console.log(&#x27;bar..&#x27;, rest) \n}\n\nfoo(); bar();\n&#x2F;&#x2F; =&gt; foo.. [Arguments]\n&#x2F;&#x2F; =&gt; bar.. []\n\nfoo(1); bar(1);\n&#x2F;&#x2F; =&gt; foo.. [Arguments] { &#x27;0&#x27;: 1 }\n&#x2F;&#x2F; =&gt; bar.. [ 1 ]\n\nfoo(1, 2); bar(1, 2);\n&#x2F;&#x2F; =&gt; foo.. [Arguments] { &#x27;0&#x27;: 1, &#x27;1&#x27;: 2 }\n&#x2F;&#x2F; =&gt; bar.. [ 1, 2 ]\n</code></pre></li>\n<li>\n<p>caller：指向函数的调用者，在 ‘use strict’ 严格模式下无法使用：</p>\n<pre class=\"prettyprint language-javascript\"><code>\nfunction foo() { console.log(foo.caller) }\n\nfunction bar() { foo() }\n\nbar();\n&#x2F;&#x2F; =&gt; [Function: bar]\n</code></pre></li>\n<li>\n<p>prototype：指向函数的原型，与 JavaScript 中的原型链相关，这里不做展开。</p>\n</li>\n</ol>\n<h3>属性描述符操作</h3>\n<p>知道了属性描述符的字段和作用，那么当然要尝试对其进行修改，在 JavaScript 中有四种方法可以对其进行修改，分别为：</p>\n<ul>\n<li>Object.defineProperty(obj, prop, descriptor)：当属性的 configurable 为 true 时，可以对已有的属性的描述符进行变更。</li>\n<li>Object.preventExtensions(obj)：阻止 obj 被添加新的属性。</li>\n<li>Object.seal(obj)：阻止 obj 被添加新的属性或者删除已有的属性。</li>\n<li>Object.freeze(obj)：阻止 obj 被添加新的属性、删除已有的属性或者更新已有的属性。</li>\n</ul>\n<p>通过这些函数可以实现一些有意思的功能，例如阻止数组新添或删除元素：</p>\n<pre class=\"prettyprint language-javascript\"><code>const arr = [ 1 ];\n\narr.push(2);\n&#x2F;&#x2F; =&gt; TypeError: Cannot add property 1, object is not extensible\n\narr.pop();\n&#x2F;&#x2F; =&gt; TypeError: Cannot delete property &#x27;0&#x27; of [object Array]\n</code></pre><p><img src=\"https://ws1.sinaimg.cn/large/005XbUDxgy1fup9bsn2igg30ev045744.gif\" alt=\"三种方式对比\"></p>\n<h3>回到源码</h3>\n<p>现在再来看  <a href=\"https://www.npmjs.com/package/mimic-fn\">mimic-fn</a> 的源码就十分简单了，其实它只做了两件事情：</p>\n<ol>\n<li>读取原函数的属性。</li>\n<li>将原函数的属性设置到新函数上。</li>\n</ol>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; 源码 3-1\nmodule.exports = (to, from) =&gt; {\n\tfor (const prop of Object.getOwnPropertyNames(from).concat(Object.getOwnPropertySymbols(from))) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n</code></pre><p>这段代码只有一个地方需要解释一下：当对象的属性为 Symbol 类型时，<code>getOwnPropertyNames</code> 无法获得，需要再通过 <code>getOwnPropertySymbols</code> 获得之后访问：</p>\n<pre class=\"prettyprint language-javascript\"><code>const obj= {\n   x: 1,\n   [Symbol(&#x27;elvin&#x27;)]: 2,\n};\n\nconsole.log(Object.getOwnPropertyNames(obj));\n&#x2F;&#x2F; =&gt; [ &#x27;x&#x27; ]\n\nconsole.log(Object.getOwnPropertySymbols(obj));\n&#x2F;&#x2F; =&gt; [ Symbol(elvin) ]\n\nconsole.log(Reflect.ownKeys(obj));\n&#x2F;&#x2F; =&gt; [ &#x27;x&#x27;, Symbol(elvin) ]\n</code></pre><p>可以看到 <code>Object.getOwnPropertyNames()</code> 只能获得 x，而 <code>Object.getOwnPropertySymbols(obj)</code> 只能获得 Symbol(‘elvin’)，两者一起使用的话则可以获得对象所有的属性。</p>\n<p>另外对于 Node.js &gt;= 6.0，可以通过 <code>Reflect.ownKeys(obj)</code> 的方式来实现同样的功能，而且代码更加的简洁，所以我尝试做了如下的更改：</p>\n<pre class=\"prettyprint language-javascript\"><code>module.exports = (to, from) =&gt; {\n\tfor (const prop of Reflect.ownKeys(from)) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n</code></pre><blockquote>\n<p>上述代码目前已被合进最新的 master 分支，详情可查看 <a href=\"https://github.com/sindresorhus/mimic-fn/pull/9\">mimic-fn PR#9</a>。</p>\n</blockquote>\n<h2>写在最后</h2>\n<p>今天所写的内容在平时工作中其实几乎不会用到，所以假如大家要问了解这个有什么用的话?</p>\n<p><em>了解这个没用，看完忘记了也没问题，开心就好，权当对 JavaScript 内部机制多了一些了解。</em></p>\n<blockquote>\n<p>关于我：毕业于华科，工作在腾讯，<a href=\"https://segmentfault.me/\">elvin 的博客</a> 欢迎来访 ^_^</p>\n</blockquote>\n</div>",
      "title": "每天阅读一个 npm 模块（3）- mimic-fn",
      "last_reply_at": "2018-08-31T07:42:44.280Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 255,
      "create_at": "2018-08-28T04:45:41.135Z",
      "author": {
        "loginname": "elvinn",
        "avatar_url": "https://avatars0.githubusercontent.com/u/28722527?v=4&s=120"
      }
    },
    {
      "id": "5b7f8a2c944cb8340c27e335",
      "author_id": "5b72f6727271129a2f32a97f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享：\n<a href=\"https://pan.baidu.com/s/1O2C6TolDzYpMnKIfQaaqog\">Nodejs视频教程</a>\n<a href=\"https://pan.baidu.com/s/1KNaA97kGwNhavch5rP_G7w\">Koa2教程</a>\n<a href=\"https://pan.baidu.com/s/17jllW0igIOWjM3YCvWS-bg\">6月Typescript教程</a>\n<a href=\"https://pan.baidu.com/s/1a8-RY-aBm3YkH2ZqJKmztg\">8月Eggjs视频教程</a>\n需要更多学习资源可留下邮箱，有的就分享</p>\n</div>",
      "title": "2018年Nodejs Koa2 Typescript Eggjs Vue2最新教程资源网盘分享",
      "last_reply_at": "2018-08-31T06:44:23.090Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 401,
      "create_at": "2018-08-24T04:31:40.973Z",
      "author": {
        "loginname": "chengl123",
        "avatar_url": "https://avatars3.githubusercontent.com/u/42384077?v=4&s=120"
      }
    },
    {
      "id": "5b87a3a1632c7f422e5b82a9",
      "author_id": "5976b9b80c87675e74674819",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>做了一个小项目，需求是利用海康威视的网络摄像头，来监控某个区域，如果有人出现的话呢，就上报告警信息，本来我是想着用萤石云来获得相关的消息的，但是需要付费，所以只能通过海康产品自己的SDK来二次开发了，我后台是用node js写的，现在海康这个是用C++写的，我要写一段C++的程序，来监听网络摄像头，看是否有报警，写好之后，应该怎么样用node js 来调用这段C++的代码，以获得报警信息，从而为在node js程序里面进行处理提供相应的参数呢？？？</p>\n</div>",
      "title": "node js 调用 C++程序",
      "last_reply_at": "2018-08-31T06:43:21.175Z",
      "good": false,
      "top": false,
      "reply_count": 6,
      "visit_count": 208,
      "create_at": "2018-08-30T07:58:25.808Z",
      "author": {
        "loginname": "quanpf2481",
        "avatar_url": "https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"
      }
    },
    {
      "id": "5b880dff08d0b0fb2d8e6d50",
      "author_id": "5afe58a81b02288048bd11f3",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>例如下面的效果是怎样做到的？？？有什么库吗？\n<img src=\"//dn-cnode.qbox.me/Fvbv0fqc2ruSoZUfc68Y9BcVTAqS\" alt=\"2018-08-30_232545.png\"></p>\n</div>",
      "title": "在页面中显示代码",
      "last_reply_at": "2018-08-31T06:40:55.096Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 122,
      "create_at": "2018-08-30T15:32:15.634Z",
      "author": {
        "loginname": "yuanshuai007",
        "avatar_url": "https://avatars2.githubusercontent.com/u/29766851?v=4&s=120"
      }
    },
    {
      "id": "5b85188cfad9359e2e831284",
      "author_id": "5976b9b80c87675e74674819",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近做了一款聊天室的app，用socket io来做长连接，一般是监听事件，然后进行相应的处理，但是如果现在想往客户端主动推送一些消息的话，应该怎么来处理呢？？？有没有相关的参考或者例子或者思路都可以，谢谢！！！</p>\n</div>",
      "title": "socket io 推送消息的问题",
      "last_reply_at": "2018-08-31T06:39:40.223Z",
      "good": false,
      "top": false,
      "reply_count": 8,
      "visit_count": 289,
      "create_at": "2018-08-28T09:40:28.412Z",
      "author": {
        "loginname": "quanpf2481",
        "avatar_url": "https://avatars3.githubusercontent.com/u/30330930?v=4&s=120"
      }
    },
    {
      "id": "5b88c83c08d0b0fb2d8e6d86",
      "author_id": "5875bd3d06fa6e2a4e4f730b",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>本文参考了官方教程Kaleidoscope语言的实现，本文只实现了JS的编译器的demo，如果想要加深学习比如语言的JIT的实现和语言的代码优化，我将官方教程和代码集合打包在了 <a href=\"https://github.com/zy445566/llvm-guide-zh\">github.com/zy445566/llvm-guide-zh</a> 中有兴趣，可以更加深入的学习。</p>\n<h1>什么是LLVM</h1>\n<p>像大家熟知的Swift就是依靠LLVM实现的一门语言，还有Rust也是将LLVM用于后端编译。\n一句话总结，它就是一种编译器的基础设施。可能有人说是gcc一类的东西么？老实说最初它却是用来取代gcc的，但它拥有的绝不是编译而是拥有制造新语言能力的全部能力的一个工具。可以让人更加无痛的实现一门语言。\n本文编译器流程大概是【编写AST用于分析语言结构】-&gt;【将分析的语言绑定生成IR(中间语言)】-&gt; 【生成二进制或汇编代码】\n如果使用LLVM制作语言的虚拟机亦可以实现JIT，或者是编译器和虚拟机的结合体。</p>\n<h1>准备工作</h1>\n<h2>安装LLVM</h2>\n<pre class=\"prettyprint language-sh\"><code># centOS，ubuntu应该也可以使用yum或apt-get进行安装\n# 有时间的话下载源码编译当然更好\nbrew install llvm\n</code></pre><h2>mac还需要安装xcode命令行工具</h2>\n<pre class=\"prettyprint language-sh\"><code># 两台电脑都装了xcode,一台编译居然找不到标准库\n# 这个问题我找了好久\nxcode-select --install\n</code></pre><h1>编写AST用于分析语言结构阶段</h1>\n<p>先定义token类型，用于识别词法结构，定义负数的原因是ascii码的字符都是正数</p>\n<pre class=\"prettyprint language-h\"><code>enum Token{\n    tok_eof = -1,\n    &#x2F;&#x2F; define\n    tok_var = -2,\n    tok_func = -3,\n    &#x2F;&#x2F; code type\n    tok_id = -4,\n    tok_exp = -5,\n    tok_num = -6,\n    &#x2F;&#x2F; choose\n    tok_if = -7,\n    tok_else = -8,\n    &#x2F;&#x2F; interrupt\n    tok_return = -9,\n    &#x2F;&#x2F; other\n    tok_unkown = -9999\n};\n</code></pre><p>解析token的方法，也可以用于字符跳跃</p>\n<pre class=\"prettyprint language-cpp\"><code>static int gettoken()\n{\n    LastChar = fgetc(fp);\n    &#x2F;&#x2F; 排除不可见字符\n    while (isspace(LastChar))\n    {\n        LastChar = fgetc(fp);\n    }\n    &#x2F;&#x2F; 排除注释\n    if (LastChar==&#x27;&#x2F;&#x27; &amp;&amp; (LastChar = fgetc(fp))==&#x27;&#x2F;&#x27;){\n        do{\n            LastChar = fgetc(fp);\n        } \n        while (!feof(fp) &amp;&amp; LastChar != &#x27;\\n&#x27; &amp;&amp; LastChar != &#x27;\\r&#x27; &amp;&amp; LastChar != 10);\n        &#x2F;&#x2F; 吃掉不可见字符\n        while (isspace(LastChar))\n        {\n            LastChar = fgetc(fp);\n            if (LastChar==&#x27;&#x2F;&#x27;) {fseek(fp,-1L,SEEK_CUR);}\n        }\n    }\n    &#x2F;&#x2F; 解析[a-zA-Z][a-zA-Z0-9]*\n    if (isalpha(LastChar)) {\n        defineStr = LastChar;\n        int TmpChar;\n        while (isalnum((TmpChar = fgetc(fp))) &amp;&amp; (LastChar = TmpChar))\n        {\n            defineStr += TmpChar;\n        }\n        fseek(fp,-1L,SEEK_CUR);\n        if (defineStr == &quot;var&quot;)\n        {\n            return tok_var;\n        }\n        if (defineStr == &quot;function&quot;)\n        {\n            return tok_func;\n        }\n        if (defineStr == &quot;if&quot;)\n        {\n            return tok_if;\n        }\n        if (defineStr == &quot;else&quot;)\n        {\n            return tok_else;\n        }\n        if (defineStr == &quot;return&quot;)\n        {\n            return tok_return;\n        }\n        return tok_id;\n    }\n    &#x2F;&#x2F; 解析[0-9.]+\n    if (isdigit(LastChar) || LastChar == &#x27;.&#x27;) {\n        std::string NumStr;\n        do {\n        NumStr += LastChar;\n        LastChar = fgetc(fp);\n        } while (isdigit(LastChar) || LastChar == &#x27;.&#x27;);\n        NumVal = strtod(NumStr.c_str(), nullptr);\n        return tok_num;\n    }\n    if(feof(fp)){\n        return tok_eof;\n    }\n    return LastChar;\n}\n</code></pre><p>再次定义语法结构数的语法，这个可以根据自己的喜好定义</p>\n<pre class=\"prettyprint language-h\"><code>&#x2F;&#x2F; AST基类\nclass ExprAST {\npublic:\n  virtual ~ExprAST() = default;\n  &#x2F;&#x2F; 这是用于实现IR代码生成的东西\n  virtual llvm::Value *codegen() = 0;\n};\n\n&#x2F;&#x2F; 定义解析的数字的语法树\nclass NumberExprAST : public ExprAST {\n  double Val;\n\npublic:\n  NumberExprAST(double Val) : Val(Val) {}\n  llvm::Value *codegen() override;\n};\n\n&#x2F;&#x2F; 定义解析的变量的语法树\nclass VariableExprAST : public ExprAST {\n  std::string Name;\n\npublic:\n  VariableExprAST(const std::string &amp;Name) : Name(Name) {}\n  llvm::Value *codegen() override;\n};\n&#x2F;&#x2F; 还有很多语法类型，由于太多，暂时不写\n...\n</code></pre><p>循环获取token并进入对应的方法</p>\n<pre class=\"prettyprint language-cpp\"><code>static void LoopParse() {\n    while (true) {\n        LastChar = gettoken();\n        switch (LastChar) {\n        case tok_eof:\n            return;\n        case &#x27;;&#x27;:\n            gettoken();\n            break;\n        case tok_func:\n            HandleFunction();\n            break;\n        case tok_if:\n            HandleIf();\n            break;\n        default:\n            break;\n        }\n    }\n}\n</code></pre><p>解析JS方法的功能</p>\n<pre class=\"prettyprint language-cpp\"><code>static std::unique_ptr&lt;FunctionAST&gt; HandleFunction() {\n    LastChar = gettoken();\n    &#x2F;&#x2F; 解析方法的参数\n    auto Proto = ParsePrototype();\n    if (!Proto){return nullptr;}\n    &#x2F;&#x2F; 吃掉方法的大括号\n    gettoken();\n    if (LastChar != &#x27;{&#x27;){return LogErrorF(&quot;Expected &#x27;{&#x27; in prototype&quot;);}\n    &#x2F;&#x2F; 定义方法的内容，这是一个数组，因为方法是多行的\n    std::vector&lt;FnucBody&gt; FnBody;\n    while(true){\n        &#x2F;&#x2F; 这是这一行代码的类型，其中包含表达式和是否返回数据\n        FnucBody fnRow;\n        if (auto E = ParseExpression())\n        {\n            fnRow.expr_row = std::move(E);\n            fnRow.tok = RowToken;\n            RowToken = 0;\n            FnBody.push_back(std::move(fnRow));\n        } else {\n            &#x2F;&#x2F; 如果这一行是分号，让下一次gettoken去吃掉分号\n            if (LastChar == &#x27;;&#x27;){continue;}\n            &#x2F;&#x2F; 如果方法结束判断是否有大括号，没有则报异常\n            if (LastChar != &#x27;}&#x27;){return LogErrorF(&quot;Expected &#x27;}&#x27; in prototype&quot;);}\n            &#x2F;&#x2F; 生成方法的AST\n            auto FnAST = llvm::make_unique&lt;FunctionAST&gt;(std::move(Proto), std::move(FnBody));\n            &#x2F;&#x2F; 生成方法的代码\n            if (auto *FnIR = FnAST-&gt;codegen()) {\n                &#x2F;&#x2F;异常则输出错误, 未出异常则输出IR\n                &#x2F;&#x2F; FnIR-&gt;print(llvm::errs());\n            }\n            return FnAST;\n        }\n    }\n    return nullptr;\n}\n</code></pre><p>而里面比较复杂应该是ParseExpression，用于解析表达式的方法,复杂点在于表达式中可能还有表达式，表达式里面还有表达式，有的时候思考下来，脑子里面基本是无限递归，能让脑子瞬间短路</p>\n<pre class=\"prettyprint language-cpp\"><code>&#x2F;&#x2F; 表达式解析\nstatic std::unique_ptr&lt;ExprAST&gt; ParseExpression() {\n    &#x2F;&#x2F; 解析表达式的左边\n    auto LHS = ParsePrimary();\n    if (!LHS){\n        return nullptr;\n    }\n    &#x2F;&#x2F; 解析表达式的操作符和表达式的右边\n    return ParseBinOpRHS(0, std::move(LHS));\n}\n&#x2F;&#x2F; 判断表达式左边是什么类型\nstatic int RowToken = 0;\nstatic std::unique_ptr&lt;ExprAST&gt; ParsePrimary() {\n  int res = gettoken();\n  switch (res) {\n  default:\n    return LogError(&quot;unknown token when expecting an expression&quot;);\n  case tok_id:\n    &#x2F;&#x2F; 如果是变量或执行的方法\n    return ParseIdentifierExpr();\n  case tok_if:\n    &#x2F;&#x2F; 如果是if\n    return HandleIf();\n  case tok_num:\n    &#x2F;&#x2F; 如果是数字\n    return ParseNumberExpr();\n  case tok_return:\n    &#x2F;&#x2F; 如果是返回则标记，并继续执行表达式左边\n    RowToken = tok_return;\n    return ParsePrimary();\n  case &#x27;}&#x27;:\n    &#x2F;&#x2F; 符号跳过\n    return nullptr;\n  case &#x27;;&#x27;:\n    &#x2F;&#x2F; 符号跳过\n    return nullptr;\n  case &#x27;(&#x27;:\n    &#x2F;&#x2F; 作为父表达式运行\n    return ParseParenExpr();\n  }\n}\n&#x2F;&#x2F; 解析表达式的操作符和表达式的右边\nstatic std::unique_ptr&lt;ExprAST&gt; ParseBinOpRHS(\n    int ExprPrec,\n    std::unique_ptr&lt;ExprAST&gt; LHS\n) {\n  gettoken();\n  while (true) {\n    &#x2F;&#x2F; 判断操作符优先级\n    int TokPrec = GetTokPrecedence();\n    &#x2F;&#x2F; 如果操作符优先级低，直接返回当前\n    if (TokPrec &lt; ExprPrec){return LHS;}\n    &#x2F;&#x2F; 如果操作符优先级高，继续运算\n    int BinOp = LastChar;\n    &#x2F;&#x2F; 分析右表达式\n    auto RHS = ParsePrimary();\n    if (!RHS){return nullptr;}\n    &#x2F;&#x2F; 继续表表达式\n    int NextPrec = GetTokPrecedence();\n    &#x2F;&#x2F; 继续分析操作符优先级\n    if (TokPrec &lt; NextPrec) {\n      RHS = ParseBinOpRHS(TokPrec + 1, std::move(RHS));\n      if (!RHS){return nullptr;}\n    }\n    &#x2F;&#x2F; 将左右表达式合并\n    LHS = llvm::make_unique&lt;BinaryExprAST&gt;(BinOp, std::move(LHS),\n                                           std::move(RHS));\n  }\n}\n\n</code></pre><h1>将分析的语言绑定生成IR(中间语言)</h1>\n<p>看完上面的是不是觉得有点慌，其实解析好了，生成IR很简单。IR是一个中间语言，简单就是把一门语言转换成另一门语言，而解析好了的话，其实就只剩下绑定了。\n先看看方法的AST的定义</p>\n<pre class=\"prettyprint language-h\"><code>&#x2F;&#x2F; 方法中的一行的类型定义\nstruct FnucBody{\n    &#x2F;&#x2F; 是否有token\n    int tok;\n    &#x2F;&#x2F; 这一行的表达式\n    std::unique_ptr&lt;ExprAST&gt; expr_row;\n};\nclass FunctionAST {\n  &#x2F;&#x2F; 参数列表定义\n  std::unique_ptr&lt;PrototypeAST&gt; Proto;\n  &#x2F;&#x2F; 方法中全部表达式行\n  std::vector&lt;FnucBody&gt; FnBody;\n\npublic:\n  &#x2F;&#x2F; 构造\n  FunctionAST(std::unique_ptr&lt;PrototypeAST&gt; Proto,\n              std::vector&lt;FnucBody&gt; FnBody)\n      : Proto(std::move(Proto)), FnBody(std::move(FnBody)) {}\n  &#x2F;&#x2F;  定义IRcode的生成方法\n  llvm::Function *codegen();\n};\n</code></pre><p>具体生成IR的方法</p>\n<pre class=\"prettyprint language-h\"><code>llvm::Function *FunctionAST::codegen() {\n  &#x2F;&#x2F; 获取函数名，并检测是否是已存在的函数\n  llvm::Function *TheFunction = TheModule-&gt;getFunction(Proto-&gt;getName());\n  \n  &#x2F;&#x2F; 如果函数不存在，则生成行数及参数并将函数重新赋值\n  if (!TheFunction)\n    TheFunction = Proto-&gt;codegen();\n  \n  &#x2F;&#x2F; 如果没生成成功，说明参数存在问题\n  if (!TheFunction)\n    return nullptr;\n\n  &#x2F;&#x2F; 在上下文中将entry语法块插入方法中\n  llvm::BasicBlock *BB = llvm::BasicBlock::Create(TheContext, &quot;entry&quot;, TheFunction);\n  Builder.SetInsertPoint(BB);\n\n  &#x2F;&#x2F; 将参数写入map中\n  NamedValues.clear();\n  for (auto &amp;Arg : TheFunction-&gt;args())\n    NamedValues[Arg.getName()] = &amp;Arg;\n\n  &#x2F;&#x2F; 遍历每一行并生成代码，如果token是return，则设置返回数据\n  for (unsigned i = 0, e = FnBody.size(); i != e; ++i) {\n    llvm::Value *RetVal = FnBody[i].expr_row-&gt;codegen();\n    if (FnBody[i].tok==tok_return){\n      Builder.CreateRet(RetVal);\n    }\n    &#x2F;&#x2F; 如果全部的行执行完成则校验方法并返回方法\n    if(i+1==e){\n      verifyFunction(*TheFunction);\n      return TheFunction;\n    }\n    \n  }\n  &#x2F;&#x2F; 发生错误移除方法\n  TheFunction-&gt;eraseFromParent();\n  return nullptr;\n}\n</code></pre><h1>生成二进制文件</h1>\n<pre class=\"prettyprint language-h\"><code>int destFile (std::string FileOrgin) {\n  &#x2F;&#x2F; 初始化发出目标代码的所有目标\n  llvm::InitializeAllTargetInfos();\n  llvm::InitializeAllTargets();\n  llvm::InitializeAllTargetMCs();\n  llvm::InitializeAllAsmParsers();\n  llvm::InitializeAllAsmPrinters();\n  &#x2F;&#x2F; 使用我们的目标三元组来获得Target\n  auto TargetTriple = llvm::sys::getDefaultTargetTriple();\n  TheModule-&gt;setTargetTriple(TargetTriple);\n\n  std::string Error;\n  auto Target = llvm::TargetRegistry::lookupTarget(TargetTriple, Error);\n\n  if (!Target) {\n    llvm::errs() &lt;&lt; Error;\n    return 1;\n  }\n\n  auto CPU = &quot;generic&quot;;\n  auto Features = &quot;&quot;;\n\n  llvm::TargetOptions opt;\n  auto RM = llvm::Optional&lt;llvm::Reloc::Model&gt;();\n  &#x2F;&#x2F; 将编译的机器信息录入\n  auto TheTargetMachine =\n      Target-&gt;createTargetMachine(TargetTriple, CPU, Features, opt, RM);\n  &#x2F;&#x2F; 通过了解目标和数据布局，优化代码\n  TheModule-&gt;setDataLayout(TheTargetMachine-&gt;createDataLayout());\n  \n  &#x2F;&#x2F; 定义文件流\n  std::string  Filename = FileOrgin+&quot;.o&quot;;\n  std::error_code EC;\n  llvm::raw_fd_ostream dest(Filename, EC, llvm::sys::fs::F_None);\n\n  if (EC) {\n    llvm::errs() &lt;&lt; &quot;Could not open file: &quot; &lt;&lt; EC.message();\n    return 1;\n  }\n  \n  &#x2F;&#x2F; 代码写入流中\n  llvm::legacy::PassManager pass;\n  auto FileType = llvm::TargetMachine::CGFT_ObjectFile;\n\n  if (TheTargetMachine-&gt;addPassesToEmitFile(pass, dest, FileType)) {\n    llvm::errs() &lt;&lt; &quot;TheTargetMachine can&#x27;t emit a file of this type&quot;;\n    return 1;\n  }\n  &#x2F;&#x2F; 完成并清除流\n  pass.run(*TheModule);\n  dest.flush();\n  &#x2F;&#x2F; 输出完成提示\n  llvm::outs() &lt;&lt; &quot;Wrote &quot; &lt;&lt; Filename &lt;&lt; &quot;\\n&quot;;\n  return 0;\n}\n</code></pre><h1>编译编译器</h1>\n<p>将我们做好的编译器编译出来，生成jsvm文件</p>\n<pre class=\"prettyprint language-sh\"><code>clang++ -g -O3 jsvm.cpp  &#96;llvm-config --cxxflags --ldflags --system-libs --libs all&#96; -o jsvm\n</code></pre><h1>使用我们写好的编译器编译js文件</h1>\n<h2>编译js</h2>\n<p>js文件如下</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; fibo.js 这是斐波纳切数\nfunction fibo(num) {\n    if (num&lt;3) {\n        return 1;\n    } else {\n        return fibo(num-1)+fibo(num-2);\n    }\n}\n</code></pre><p>开始编译js文件，将生成 fibo.js.o,如下</p>\n<pre class=\"prettyprint language-sh\"><code>.&#x2F;jsvm fibo.js\n</code></pre><p><img src=\"//dn-cnode.qbox.me/FiJ2dDPRtfi7dOh5UnJv4YiHHhde\" alt=\"outfibo.png\"></p>\n<h2>使用c引用js文件，并编译成二进制文件</h2>\n<p>c代码如下：</p>\n<pre class=\"prettyprint language-cpp\"><code>&#x2F;&#x2F; main.cpp\n#include &lt;iostream&gt;\n\nextern &quot;C&quot; {\n    double fibo(double);\n}\n\nint main() {\n    std::cout &lt;&lt; &quot;fibo(9) is: &quot; &lt;&lt; fibo(9) &lt;&lt; std::endl;\n}\n</code></pre><p>编译并运行,如下：</p>\n<pre class=\"prettyprint language-sh\"><code>clang++ main.cpp fibo.js.o -o main &amp;&amp; .&#x2F;main\n</code></pre><p><img src=\"//dn-cnode.qbox.me/FsfgxElQOCRfYwxvroAPKV0Yk31-\" alt=\"outmain.png\"></p>\n<h1>总结</h1>\n<p>第一次写编译器感觉很凌乱，编译器本身来说还算是一个相对复杂的工程，加上js语言的灵活多变性，实现起来可能更加困难，不过这作为一个学习的例子应该是不错的，遂与大家分享。\n相信llvm将来也是能为JS助力的，事实上已经有人有很大胆的想法去使用llvm编译JS，前段时间facebook的prepack就有这样一个PR<a href=\"https://github.com/facebook/prepack/pull/2264\">【facebook/prepack/pull/2264】</a>去实现用llvm将js编译成二进制而无需运行时。兄弟们！JS自举的路或许不会太远了。</p>\n</div>",
      "title": "利用LLVM实现JS的编译器，创造属于自己的语言",
      "last_reply_at": "2018-08-31T05:30:58.557Z",
      "good": false,
      "top": false,
      "reply_count": 2,
      "visit_count": 119,
      "create_at": "2018-08-31T04:46:52.390Z",
      "author": {
        "loginname": "zy445566",
        "avatar_url": "https://avatars2.githubusercontent.com/u/14976489?v=4&s=120"
      }
    },
    {
      "id": "5b88d2502a585e4e2f270048",
      "author_id": "574f864ac4257a455bd076cf",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>Iceworks 2.7.0 发布，海量图表供你选择</h2>\n<blockquote>\n<p>Iceworks，丰富模板一键创建，提供多种垂直领域模板，快速创建项目，支持风格切换，满足个性化需求；轻松操作页面管理，海量物料自由搭配，页面组合可视化操作更得心应手；开发调试一体化，集成运行环境零配置运行，开箱即用。</p>\n</blockquote>\n<p><a href=\"https://juejin.im/post/5b6349716fb9a04f834669d6\">快速了解</a></p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1JPTpupkoBKNjSZFEXXbrEVXa-2848-1408.png\" alt=\"cover\"></p>\n<h2>2.7.0 发布概览</h2>\n<ul>\n<li>特性：新增官方推荐物料集合，内置支持 Bizcharts 的所有图表\b</li>\n<li>优化：初次使用项目界面增加项目创建引导项</li>\n<li>修复：自定义物料源在 scaffolds 的情况下卡死的问题</li>\n<li>模板：丰富的 React、Vue、Angular 模板</li>\n</ul>\n<h2>Bizcharts 物料源</h2>\n<p><a href=\"https://juejin.im/post/5b847de8f265da4340158800\">阿里巴巴图表库 Bizcharts 正式开源</a> Bizcharts 是基于 <a href=\"https://antv.alipay.com/zh-cn/g2/3.x/index.html\">G2</a> 引擎的 React 版本的封装。 Bizcharts 的语法设计非常贴切 React 的使用方式，图表的各个部分都拆分成了独立的 React 类，如：<code>&lt;Tooltip /&gt;</code> 代表提示信息， <code>&lt;Axis /&gt;</code> 代表坐标轴。 所有图表的配置项皆为组件的 <code>props</code> 。</p>\n<p>正式开源之后，飞冰与 Bizcharts 团队联合推出了图表类物料源，以内置推荐的形式更新到 Iceworks 2.7.0 版本，在设置面板中开启即可使用。该物料源主要由 Bizcharts 团队成员开发和维护，在一定程度能保证该物料源的持续更新和及时反馈。包括：</p>\n<ul>\n<li>200 多个图表类区块</li>\n<li>6 套图表类可视化模板</li>\n</ul>\n<h3>图表类可视化模板</h3>\n<ul>\n<li><a href=\"https://g.alicdn.com/bizcharts-material/scaffold-ad/0.0.5/index.html#/\">广告数据首页</a></li>\n<li><a href=\"https://g.alicdn.com/bizcharts-material/scaffold-cira-crowd/0.0.6/index.html#/\">人群画像分析</a></li>\n<li><a href=\"https://g.alicdn.com/bizcharts-material/2016-olympic-nbc/0.0.6/index.html#/\">电视广告传播分析屏</a></li>\n<li><a href=\"https://g.alicdn.com/bizcharts-material/scaffold-screen-demo/0.0.3/index.html#/\">可视化大屏</a></li>\n<li><a href=\"https://g.alicdn.com/bizcharts-material/scaffold-screen-demo/0.0.3/index.html#/\">监控预警大屏-折线图</a></li>\n</ul>\n<p><img src=\"https://img.alicdn.com/tfs/TB1AfuJurorBKNjSZFjXXc_SpXa-1908-1368.png\" alt=\"image\"></p>\n<h3>丰富的图表类区块</h3>\n<p><img src=\"https://img.alicdn.com/tfs/TB15jO3uBjTBKNjSZFDXXbVgVXa-1908-1368.png\" alt=\"image\"></p>\n<hr>\n<h2>其他物料源</h2>\n<p>除了增加对 React 物料源的支持，我们也增加对 Vue 和 Angular 的支持；可通过 Iceworks 直接创建 Vue 或者 Angular 项目，主要由社区进行维护。</p>\n<h3>Vue 模板</h3>\n<p><a href=\"https://github.com/d2-projects/d2-admin\">D2Admin</a> 是一个开源的管理系统前端集成方案，为了方便开发者快速进行管理系统开发而设计，提供了大量开箱即用的功能：</p>\n<ul>\n<li>登陆和注销的页面、逻辑、路由拦截</li>\n<li>主题系统</li>\n<li>基于 ElementUI 的优化外观</li>\n<li>表格 CRUD 封装 (<a href=\"https://github.com/d2-projects/d2-crud\">d2-crud</a>)</li>\n<li>完善的页面容器组件，六种布局模式，具备顶栏和底栏插槽</li>\n<li>表格导入导出</li>\n<li>错误处理</li>\n<li>模拟数据</li>\n<li>集成字体图标库，以及即放即用的 svg 图标组件</li>\n<li>同类产品中最强大的出具持久化方案</li>\n<li>完善的多标签页用户控制</li>\n<li>完善的全局系统控制</li>\n</ul>\n<p>D2 Admin 主要由社区 <a href=\"https://github.com/FairyEver\">FairyEver</a> 维护，为了方便开发者快速开发推出的 D2 Admin ICE 和完整版的 D2 Admin 有完全一致的系统功能。D2 Admin ICE 和其它分支同时更新。<a href=\"http://app.d3collection.cn/d2-admin-doc/lastest/zh/learn-guide/\">D2 Admin 中文文档 | 介绍</a></p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1una5upkoBKNjSZFEXXbrEVXa-1908-1368.png\" alt></p>\n<h3>Angular 模板</h3>\n<p><img src=\"https://img.alicdn.com/tfs/TB14.UDuoOWBKNjSZKzXXXfWFXa-1908-1368.png\" alt></p>\n<hr>\n<h2>自定义编辑器启动脚本</h2>\n<p>Iceworks 默认内置了 VSCode、SublimeText、Atom、WebStorm 等，但很难覆盖所有用户的编辑器选择。</p>\n<p>因此在改版本中增加了自定义编辑器启动脚本的功能。</p>\n<p>例如启动 VSCode 的命令是 <code>code</code>，将脚本定义为 <code>code ${cwd}</code> 即可。</p>\n<p><code>${cwd}</code> 在执行时会被替换成当前的项目地址</p>\n<p><img src=\"https://img.alicdn.com/tfs/TB1.7uKurorBKNjSZFjXXc_SpXa-1908-1368.png\" alt=\"image\"></p>\n<hr>\n<p>扩展信息</p>\n<ul>\n<li>官方网站：<a href=\"https://alibaba.github.io/ice/\">飞冰-让前端开发简单而友好\n</a></li>\n<li>下载 Iceworks：<a href=\"https://alibaba.github.io/ice/iceworks\">https://alibaba.github.io/ice/iceworks</a></li>\n<li>Github：<a href=\"http://github.com/alibaba/ice\">http://github.com/alibaba/ice</a></li>\n<li>飞冰群二维码：<a href=\"http://ice.alicdn.com/assets/images/qrcode.png\">点击这里查看二维码</a></li>\n<li>有兴趣加入飞冰，欢迎勾搭 <a href=\"mailto:chenbinad@gmail.com\">chenbinad@gmail.com</a></li>\n</ul>\n<hr>\n</div>",
      "title": "Iceworks 2.7.0 发布，海量图表供你选择",
      "last_reply_at": "2018-08-31T05:29:52.153Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 93,
      "create_at": "2018-08-31T05:29:52.153Z",
      "author": {
        "loginname": "chenbin92",
        "avatar_url": "https://avatars1.githubusercontent.com/u/3995814?v=4&s=120"
      }
    },
    {
      "id": "5b889b18fad9359e2e83135e",
      "author_id": "54bdaa0b514ea9146862abed",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>用nodejs写了个云服务破解excel密码，doc密码，pdf密码等工具，欢迎撸友们帮忙测试。\n<a href=\"https://www.doccrack.com\">https://www.doccrack.com</a></p>\n</div>",
      "title": "抱歉，会js真的了不起，一个云服务两天就写完了",
      "last_reply_at": "2018-08-31T05:14:57.365Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 393,
      "create_at": "2018-08-31T01:34:16.718Z",
      "author": {
        "loginname": "focalhot",
        "avatar_url": "https://avatars3.githubusercontent.com/u/6360143?v=4&s=120"
      }
    },
    {
      "id": "5b87e6cc632c7f422e5b82c0",
      "author_id": "5997f817f36051a45246c171",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>给斗鱼主播火西肆做的一个简易聊天室，随便练手，分享一下，欢迎交流。\n网址：<a href=\"http://www.suichaozi.club/\">http://www.suichaozi.club/</a>\nGithub : <a href=\"https://github.com/DoubleCG/foxisi\">https://github.com/DoubleCG/foxisi</a>\n配套文档：<a href=\"https://www.yuque.com/suichaozi/msyfio\">https://www.yuque.com/suichaozi/msyfio</a></p>\n<p><img src=\"//dn-cnode.qbox.me/Fhi2i_X0uagal6fK1zTp2B09QJiz\" alt=\"1535632942(1).jpg\"></p>\n</div>",
      "title": "Koa/Vue/Redis 简易聊天室",
      "last_reply_at": "2018-08-31T05:06:21.690Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 208,
      "create_at": "2018-08-30T12:45:00.610Z",
      "author": {
        "loginname": "DoubleCG",
        "avatar_url": "https://avatars1.githubusercontent.com/u/19707468?v=4&s=120"
      }
    },
    {
      "id": "5b7e19aea210553a0cde2b6d",
      "author_id": "59cda06f99fac4a22000408c",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近想学习一下nodejs，但我发现网上的项目教程几乎都是依赖框架（express/koa）完成的，有没有那种直接使用nodejs核心api，不使用框架开发的项目可以借鉴学习一下的？</p>\n</div>",
      "title": "有没有直接用nodejs开发的项目可以学习的？",
      "last_reply_at": "2018-08-31T05:04:49.742Z",
      "good": false,
      "top": false,
      "reply_count": 7,
      "visit_count": 426,
      "create_at": "2018-08-23T02:19:26.213Z",
      "author": {
        "loginname": "xionggen",
        "avatar_url": "https://avatars1.githubusercontent.com/u/16712701?v=4&s=120"
      }
    },
    {
      "id": "5b84df7b08d0b0fb2d8e6c6f",
      "author_id": "5b76373ba210553a0cde29cb",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我公司做的是聊天室，之前都是用轮询，不过多人同时发信息时还是会有问题试了很多方法，还是会有小概率丢失数据或者出现两条同样的数据。\n现在想转websocket，想问问一两千个人对服务器压力有多大？有什么工具能做这样面的测试？\n求分享。</p>\n</div>",
      "title": "有用 websocket 做过聊天室的朋友么？",
      "last_reply_at": "2018-08-31T04:39:45.008Z",
      "good": false,
      "top": false,
      "reply_count": 18,
      "visit_count": 470,
      "create_at": "2018-08-28T05:36:59.722Z",
      "author": {
        "loginname": "KAROTT7",
        "avatar_url": "https://avatars2.githubusercontent.com/u/21054747?v=4&s=120"
      }
    },
    {
      "id": "5b87741b2a585e4e2f26ffe6",
      "author_id": "511350f6df9e9fcc58856443",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h3>前言</h3>\n<p>互联网时代，产品迭代速度快，传统的瀑布流开发模型已经无法满足产品快速开发的需求，敏捷开发的思想应运而生。<br>\n考拉技术团队在CEO的大力推行下，一直沿用scrum开发模型，保证产品每周一次的迭代。今天我们先来入个门，了解下scrum模型的基本内容。</p>\n<h3>一、传统开发模型</h3>\n<p>在开始介绍scrum模型之前，我们先来回顾下之前软件开发模式。<br>\n起初，软件开发最基础的模型叫做瀑布模型（<strong>Waterfall Model</strong>）。瀑布模型式是最典型的预见性的方法，严格遵循预先计划的需求分析、设计、编码、集成、测试、维护的步骤顺序进行。瀑布模型下的产品开发各部分都是独立分开，各不干扰，一般适应于大型软件。\n但瀑布模型也存在不能在开发过程更改需求、无法赶上变化迅速的市场，容易造成资源浪费等缺点。<br>\n在这个基础上，引入敏捷开发模型对于小开发团队来说是比较合适的。<br>\n<img src=\"//dn-cnode.qbox.me/Fo4o88qn-J3KPciRGm2s_rSuwNz0\" alt=\"waterfall模式.png\"><br>\n<img src=\"//dn-cnode.qbox.me/Fn9V84ArKu4a59tjNVr9shv1wY6s\" alt=\"waterfall模式缺点.png\"></p>\n<h3>二、scrum的简介</h3>\n<p><strong>敏捷开发是一种以人为核心、迭代、循序渐进的开发方法。</strong></p>\n<p>Scrum作为敏捷的方法之一，用不断迭代的框架方法来管理复杂产品的开发。</p>\n<p>原词来自于橄榄球中“带球过人”。在橄榄球比赛的每次冲刺前，都将有一个计划安排的过程，但冲刺开始后则由队员在原计划的基础上随机应发。<br>\n<img src=\"//dn-cnode.qbox.me/FkEWkcu2nOklMT2WOfZGUA6-Pn7N\" alt=\"scrum原意.jpg\"></p>\n<h3>三、scrum的优势</h3>\n<p>灵活性、适应需求变化、更适合团队比较小的情况、每一个迭代均有产出，容易学习。<br>\n<strong>Why choose Scrum？</strong> 原因如下 （敏捷宣言）：</p>\n<ol>\n<li>\n<p>个体交互重于过程和工具；</p>\n</li>\n<li>\n<p>可用的软件重于完备的文档；</p>\n</li>\n<li>\n<p>客户协作重于合同谈判；</p>\n</li>\n<li>\n<p>响应变化重于遵循计划。</p>\n</li>\n</ol>\n<p>概况地说，它适用于快速变化的市场，可以根据客户不断更换的需求，调整产品的方向，按时交付客户想要的产品。这在今天竞争激烈的市场来说，优先于竞争对手交付一个不完美但能不断改进优化的产品是非常重要的。</p>\n<h3>四、scrum中3个关键角色</h3>\n<p>scrum团队的成员由开发人员、测试人员以及其他帮助研发的人组成：<br>\n核心团队：</p>\n<ul>\n<li>Scrum Master——项目负责人，帮助团队完成工作，组织日常会议和保障其他工作展开；</li>\n<li>Team——开发人员，经常扮演多种角色，开发人员兼职测试，测试人员搬砖文案；</li>\n<li>Product Owner——产品负责人，确定产品特性，提出产品亮点。<br>\nscrum团队的规模不宜过大，一般在3-9人为佳。\n<img src=\"//dn-cnode.qbox.me/FpLsqKbbt2pmJwKiKNJjGJw-BaUd\" alt=\"scrum角色.png\"></li>\n</ul>\n<h3>五、scrum流程</h3>\n<p><img src=\"//dn-cnode.qbox.me/Ftve8j0KvkAgo82xv5LXda7wbpsp\" alt=\"scrum流程.jpg\"></p>\n<ol>\n<li>建立Product Backlog<br>\n记录已知需求并调整。<br>\n在整个开发过程中，Product Owner要不断的把已知的所有需求记录到这里面来，任何时间或步骤中产生的新需求都需要进行更新。scrum团队总是先开发对需求方具有较高价值的需求。<br>\n需求方为了能更加清晰表达需求，可用<strong>user story</strong>描述需求。user story是从用户/需求方的角度对产品的某个功能进行的简短描述，具体格式如下：<br>\n<img src=\"//dn-cnode.qbox.me/Fi0FBdfKrkq6UtSMaEyEGaE19Bg_\" alt=\"微信图片_20180830111107.png\"><br>\n一个story的大小以及复杂度应以能在一个sprint中完成为宜。如果user story横跨了几个sprint，那个就需要进行分解成若干个task（任务），每个task的时间最好不要超过8小时.</li>\n<li>Sprint Planning<br>\n在scrum中，sprint定义为产品的迭代周期。一般是1~6周。在一个sprint开始前，定义本次sprint要讨论的backlo为sprint backlog.\n它是团队在sprint要完成的任务。<br>\n为了确定团队内部任务以及具体分工，需要进行sprint planing，由Scrum Master决定需求，然后将任务拆分，估时，并完成分配。当任务分配之后，要记录到sprint backlog中。在sprint中，scrum团队从backlog中挑选最高优先级的需求进行开发。\n在每次例会之后，由Scrum Master更新backlog。</li>\n<li>Daily Scrum<br>\n也称为每日站会，一般不超过15min。参会的成员由核心团队的成员组成，每个人只说3个问题：<br>\n<strong>今天完成了哪些任务？\n明天的任务是什么？\n今天遇到了哪些问题？</strong><br>\n每日站会的主要作用是update整个团队的进度，会上成员提出的问题不进行详细讨论，会议后master对这些问题进行解决。</li>\n<li>Sprint Review<br>\n总结sprint的会议，在会议上会将本次sprint的新功能展示出来，并收取反馈，为下一次新的需求做准备。</li>\n<li>Retrospective Meeting<br>\n反思sprint的会议，目的是回顾sprint过程组内成员的表现。为了让成员能够更加真实反思自己的工作情况，安全的讨论环境是必须的。在回顾会议上，主要做这三件事情：<br>\ngood–如果我们可以重做同一个sprint，哪些做法是可以保留的？<br>\ncould have done better–如果我们可以重做同一个sprint，哪些做法需要改变？<br>\nimprovement–如何改进的具体想法？</li>\n</ol>\n<h3>六、scrum工具</h3>\n<ol>\n<li>\n<p>任务板<br>\n任务板用可视化方式展示，将一个sprint分为四个阶段：<br>\nProduct Backlog：按照需求的优先级，将团队在sprint中要进行的backlog放在该列；<br>\nTo Do ：将当前sprint需要完成的任务放入该列；<br>\nIn Progress：当团队开发进行某个任务之后，便将任务对应的卡片放到该列中。如果该任务在该列中所处时间超过1天，则应该将任务拆分为更小的部分，并将新任务放到该列中，移出原有的任务。若一个新任务因某个障碍无法完成，master就会将其标记为障碍，用特定红点标记。<br>\nDone：完成一个任务之后，便将任务放到该列。继续开始下一个任务。<br>\n看板（kanban）开发方法作为一种敏捷方式，在改善协助，优化管理、提高交付速度、质量以及灵活性方面有显著作用。下篇文章会着重讲述kanban开发模型在技术团队中的应用。<br>\n<img src=\"//dn-cnode.qbox.me/Fune4wceTm4prLLmJAiVj-2PnfxS\" alt=\"看板.png\"></p>\n</li>\n<li>\n<p>燃尽图<br>\nsprint的开发时间需要团队跟进，燃尽图可以帮助团队评估sprint开发任务的时间以及效率。<br>\n燃尽图是以图表展示随着时间的减少工作量的完成情况。燃尽图的横轴表示整个Sprint 的总时间，纵轴表示 Sprint 中所有的任务，其单位可以是小时，人天等。\n为了更好表示任务开发情况，团队每天要更新燃尽图，并且要根据燃尽图中任务的完成情况对任务进行调整：如果燃尽图一直是上升状态，或当 Sprint 进行一段时间之后，Sprint 燃尽图上的Y值仍然与 Sprint 刚开始时相差无几，就说明这个 Sprint 中的 Story 过多，要拿掉一些 Story 以保证这个 Sprint 能顺利完成。 如果Sprint 燃尽图下降得很快，例如 Sprint 刚过半时Y值已经接近0了，则说明这个 Sprint 分配的任务太少，还要多加一些任务进来。<br>\n为了方便管理燃尽图，在设计燃尽图的时候，从简出发。<br>\n<img src=\"//dn-cnode.qbox.me/FmuGgZgD6WsPAMKqZMKcJPZgw4fp\" alt=\"燃尽图.png\"></p>\n</li>\n<li>\n<p>Jira<br>\n作为敏捷团队用来管理开发项目流程以及进展的工具，Jira提供了丰富的功能，方便开发团队对开发中的问题进行记录跟踪，并通过可视化图表展现出来。当团队进行一次sprint时，Jira会帮你记录任务的完成状态，团队的分工情况以及完成情况。，支持将任务简化，把开发时间分配到每个具体任务中，在规定的时间内完成任务。这与敏捷开发的思想不谋而合。</p>\n</li>\n</ol>\n<h3>七、结束语</h3>\n<p>尽管scrum很美好很轻量，但是这种模型不一定适用于所有的企业。为了保持产品的快速优化，团队在进行敏捷开发模式的同时，还应该注重敏捷开发过程的不断优化。敏捷的出发点是为了提高工作效率，以人为本。没有谁的敏捷之路是一帆风顺，不断优化，小步快跑的方式才是敏捷可行的路。</p>\n</div>",
      "title": "AI考拉技术分享--Scrum入门",
      "last_reply_at": "2018-08-31T04:34:06.631Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 158,
      "create_at": "2018-08-30T04:35:39.275Z",
      "author": {
        "loginname": "kalengo",
        "avatar_url": "https://avatars2.githubusercontent.com/u/8817810?v=4&s=120"
      }
    },
    {
      "id": "5b82b805c52ad1482eb941fa",
      "author_id": "590b033352c3650e042a7f9e",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>网页音乐播放器，（同域名）当前页面进行音乐播放，跳转另外一个链接（当前页面打开），怎样让音乐不停止并继续播放？，</p>\n</div>",
      "title": "网页音乐播放器，（同域名）当前页面进行音乐播放，跳转另外一个链接（当前页面打开），怎样让音乐不停止并继续播放？",
      "last_reply_at": "2018-08-31T04:12:21.000Z",
      "good": false,
      "top": false,
      "reply_count": 5,
      "visit_count": 342,
      "create_at": "2018-08-26T14:24:05.922Z",
      "author": {
        "loginname": "wiscgazf",
        "avatar_url": "https://avatars0.githubusercontent.com/u/26874662?v=4&s=120"
      }
    },
    {
      "id": "512b9fecdf9e9fcc580eb248",
      "author_id": "509a8cf7637ffa41553ae804",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h1><a href=\"https://github.com/zhangyuanwei/node-images\"><img src=\"https://raw.github.com/zhangyuanwei/node-images/master/demo/logo.png\" alt=\"Fork me on GitHub\"></a></h1>\n<pre class=\"prettyprint language- javascript\"><code>var images = require(&quot;images&quot;);\n\nimages(&quot;input.jpg&quot;)                     &#x2F;&#x2F;加载图像文件\n    .size(400)                          &#x2F;&#x2F;等比缩放图像到400像素宽\n    .draw(images(&quot;logo.png&quot;), 10, 10)   &#x2F;&#x2F;在(10,10)处绘制Logo\n    .save(&quot;output.jpg&quot;, {               &#x2F;&#x2F;保存图片到文件,图片质量为50\n        quality : 50\n\t});\n</code></pre><h2>Features 功能特性</h2>\n<ul>\n<li>轻量级：无需安装任何图像处理库。</li>\n<li>跨平台：Windows下发布了编译好的.node文件,下载就能用。</li>\n<li>方便用：jQuery风格的API，简单可依赖。</li>\n</ul>\n<h2>Installation 安装</h2>\n<pre class=\"prettyprint\"><code>&#96;$ npm install images&#96;\n</code></pre><h2>API 接口</h2>\n<p>node-images 提供了类似jQuery的链式调用API,您可以这样开始:</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;* 从指定文件加载并解码图像 *&#x2F;\nimages(file)\n\n&#x2F;* 创建一个指定宽高的透明图像 *&#x2F;\nimages(width, height)\n\n&#x2F;* 从Buffer数据中解码图像 *&#x2F;\nimages(buffer[, start[, end]])\n\n&#x2F;* 从另一个图像中复制区域来创建图像 *&#x2F;\nimages(image[, x, y, width, height])\n</code></pre><h3>.fill(red, green, blue[, alpha])</h3>\n<p>以指定颜色填充图像\neg:<code>images(200, 100).fill(0xff, 0x00, 0x00, 0.5)</code></p>\n<h3>.draw(image, x, y)</h3>\n<p>在当前图像( <em>x</em> , <em>y</em> )上绘制 <em>image</em> 图像</p>\n<h3>.encode(type[, config])</h3>\n<p>以指定格式编码当前图像到Buffer，config为图片设置，目前支持设置JPG图像质量\neg:<code>images(&quot;input.png&quot;).encode(&quot;jpg&quot;, {operation:50})</code>\n返回填充好的Buffer\n<strong>注意:该操作将会切断调用链</strong><br>\n参考:.save(file[, type[, config]])</p>\n<h3>.save(file[, type[, config]])</h3>\n<p>编码并保存当前图像到 <em>file</em> ,如果type未指定,则根据 <em>file</em> 自动判断文件类型，config为图片设置，目前支持设置JPG图像质量\neg:<code>images(&quot;input.png&quot;).save(&quot;output.jpg&quot;, {operation:50})</code></p>\n<h3>.size([width[, height]])</h3>\n<p>获取或者设置图像宽高，如果height未指定，则根据当前宽高等比缩放</p>\n<h3>.width([width])</h3>\n<p>获取或设置图像宽度</p>\n<h3>.height([height])</h3>\n<p>获取或设置图像高度</p>\n<h3>images.setLimit(width, height)</h3>\n<p>设置库处理图片的大小限制,设置后对所有新的操作生效(如果超限则抛出异常)。</p>\n</div>",
      "title": "【原创分享】Nodejs跨平台轻量级图片编解码库【增加Jpeg质量调整】",
      "last_reply_at": "2018-08-31T02:58:27.298Z",
      "good": true,
      "top": false,
      "reply_count": 68,
      "visit_count": 37547,
      "create_at": "2013-02-25T17:31:24.712Z",
      "author": {
        "loginname": "yourke",
        "avatar_url": "//gravatar.com/avatar/a0892cf4b7ff2828c00aa3f91ba51724?size=48"
      }
    },
    {
      "id": "5b7ac9c7c52ad1482eb940bf",
      "author_id": "5b52cbf1fb9e84ec69cc1ca2",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>Egg.js现在用的人多吗？那些公司在用有知道的吗？</p>\n<p>同上，老铁们出来吧。</p>\n</div>",
      "title": "Egg.js现在用的人多吗？那些公司在用有知道的吗？",
      "last_reply_at": "2018-08-31T02:48:40.313Z",
      "good": false,
      "top": false,
      "reply_count": 56,
      "visit_count": 2041,
      "create_at": "2018-08-20T14:01:43.981Z",
      "author": {
        "loginname": "nodeper",
        "avatar_url": "https://avatars2.githubusercontent.com/u/41500847?v=4&s=120"
      }
    },
    {
      "id": "5b875f1308d0b0fb2d8e6d07",
      "author_id": "5a94076871327bb413bbfe96",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>最近想弄个服务器学习下，怎么搭建服务</p>\n</div>",
      "title": "有没有特别便宜的服务器推荐，要求不高，学习使用",
      "last_reply_at": "2018-08-31T02:22:36.531Z",
      "good": false,
      "top": false,
      "reply_count": 8,
      "visit_count": 321,
      "create_at": "2018-08-30T03:05:55.814Z",
      "author": {
        "loginname": "SharksevenRo",
        "avatar_url": "https://avatars3.githubusercontent.com/u/8946077?v=4&s=120"
      }
    },
    {
      "id": "5b88a6562a585e4e2f27002c",
      "author_id": "5b88a3e1632c7f422e5b82f6",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>背景: socket.io+redis+nodejs+mongodb搭建的聊天系统。\n现在我需要做集群部署服务节点。由于需要监听数据库变化。我使用了mongodb的 <code>db.collection.watch()</code>.在单节点都是正常的。但是当我希望部署多节点的时候，会出现多节点重复监听的情况。现在我的想法是使用cluster，在主进程监听，子进程不监听，这样可以吗？但这样当数据库写入频繁的时候，会不会出问题？</p>\n<pre class=\"prettyprint language-javascript\"><code>\tMongooseModels.room.watch({fullDocument: &#x27;updateLookup&#x27;}).on(&#x27;change&#x27;,  (data) =&gt; {\n\t\tconst doc = data.fullDocument;\n\t\tif (doc &amp;&amp; doc.usernames) {\t\t\t\n\t\t\t_.forEach(doc.usernames, (val) =&gt; {\n\t\t\t\tio.of(&#x27;s_room&#x27;).in(val.userId).emit(&#x27;rooms-changed&#x27;, {type: data.operationType, doc});\n\t\t\t});\t\n\t\t}\n\t});\n</code></pre></div>",
      "title": "nodejs如何高性能的使用mongodb watch？",
      "last_reply_at": "2018-08-31T02:22:14.087Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 64,
      "create_at": "2018-08-31T02:22:14.087Z",
      "author": {
        "loginname": "szluohua",
        "avatar_url": "https://avatars2.githubusercontent.com/u/18567056?v=4&s=120"
      }
    },
    {
      "id": "5b88a38b2a585e4e2f27002b",
      "author_id": "5b5a9a0858db3ccf66a44fb3",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p><strong>zsh:1: permission denied: pm2\n○ hook test\n○ successfully deployed origin/master\n–&gt; Success</strong></p>\n<p>用pm2 部署到center os 服务器的时候发生这个错误，无法启动pm2 。但是在服务器 pm2 start 可以正常启动pm2</p>\n</div>",
      "title": "部署服务端的时候  permission denied: pm2 错误",
      "last_reply_at": "2018-08-31T02:10:19.479Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 66,
      "create_at": "2018-08-31T02:10:19.479Z",
      "author": {
        "loginname": "atony2099",
        "avatar_url": "https://avatars0.githubusercontent.com/u/12857007?v=4&s=120"
      }
    },
    {
      "id": "5b87969408d0b0fb2d8e6d24",
      "author_id": "5b7d5469944cb8340c27e2bb",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>问题描述：</p>\n<p>最近在使用 node 构建一个数据处理系统，涉及到的模块较多，因此打算采用微服务架构，目前使用了一个微服务框架 Seneca，采用 tcp 进行通信。</p>\n<p>Seneca 微服务主要负责和db通信、以及数据处理计算（不是很耗时的计算）。</p>\n<p>这里大部分数据处理计算的工作都可以延时完成，但是前端 http 的返回和其中的一部分工作比如数据库查询工作有关，所以需要等待某些微服务模块有返回结果了（或返回部分结果了）再返回给前端。\n于是我通过ab测试发现：采用 Seneca 的方式比原来各个模块写在一起直接引入的方式，效率要低好多，比较坏的情况下，甚至平均响应时间是原来的 1.5 倍。\n这个也不难理解，毕竟会有通信的开销，还可能因为采用了 Seneca 造成其他的隐形成本。</p>\n<p>我现在有点迷茫，采用了微服务的话，可以使模块之间解藕，对开发有一定方便，但是却会降低效率，感觉有些得不偿失。\n我对微服务的理解也并不深刻，只是觉得能在代码维护上给这种单体系统带来好处，另外就是微服务的单个服务方便扩容。</p>\n<p>是不是我的使用方式不对？还是说微服务本来就有降低效率这个问题？各位是如何解决的呢？希望能指点一二。</p>\n</div>",
      "title": "node 微服务架构是否会降低后端的效率和响应时间，有没有什么解决办法呢？",
      "last_reply_at": "2018-08-31T02:09:44.578Z",
      "good": false,
      "top": false,
      "reply_count": 10,
      "visit_count": 292,
      "create_at": "2018-08-30T07:02:44.849Z",
      "author": {
        "loginname": "aircloud",
        "avatar_url": "https://avatars3.githubusercontent.com/u/10907228?v=4&s=120"
      }
    },
    {
      "id": "5b7e18ab632c7f422e5b80b5",
      "author_id": "573212537abbbd520cb244b3",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>我在一个事务里执行了3条 sql 分别是:</p>\n<pre class=\"prettyprint language-sql\"><code>select * from table where mobile = ? for update\nselect prizeId,count(*) as amount from table where prizeRegion = ? group by prizeRegion,prizeId for update\ninsert into table (mobile,prizeId,prizeName,prizeRegion) values (?,?,?,?)\n</code></pre><p>空表的时候并发会发生死锁, 但是当表中有数据的时候就不会. 不知道哪里的问题?</p>\n</div>",
      "title": "请教一个死锁的问题",
      "last_reply_at": "2018-08-31T01:37:24.938Z",
      "good": false,
      "top": false,
      "reply_count": 10,
      "visit_count": 748,
      "create_at": "2018-08-23T02:15:07.161Z",
      "author": {
        "loginname": "dlyt",
        "avatar_url": "https://avatars0.githubusercontent.com/u/18431616?v=4&s=120"
      }
    },
    {
      "id": "5b889b3b2a585e4e2f27001b",
      "author_id": "4efc278525fa69ac690000fc",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><h2>安装</h2>\n<p><a href=\"https://github.com/SirVer/ultisnips\">Ultisnips</a> 插件安装分两部分，一个是 ultisnips 插件本身，另外一个是代码片段仓库。一般来说把默认的代码片段仓库下载下来按需修改后上传到自己的 github 即可。如果你和我一样也使用 vim-plug 来管理插件的话，添加下面的代码到你的 vimrc 中保存刷新即可</p>\n<pre class=\"prettyprint language-vim\"><code>Plug &#x27;SirVer&#x2F;ultisnips&#x27;\n&quot; 你自己的代码仓库 git 地址\nPlug &#x27;keelii&#x2F;vim-snippets&#x27;\n</code></pre><p>上面的示例中所有的代码片段都存放在插件安装目录下面的 <code>vim-snippets/UltiSnips</code> 中，文件命名格式为 <code>ft</code>.snippets, <code>ft</code> 就是 vim 中的 <code>filetype</code>，其中有个 <code>all.snippets</code> 是唯一一个所有文件都适用的代码片段</p>\n<h2>配置</h2>\n<p>快捷键设置，我一般使用 tab 来触发代码片段补全，<strong>且不使用 YCM</strong> （官方文档表示使用YCM的话就不能使用tab补全）</p>\n<pre class=\"prettyprint language-vim\"><code>let g:UltiSnipsExpandTrigger=&quot;&lt;tab&gt;&quot;\n&quot; 使用 tab 切换下一个触发点，shit+tab 上一个触发点\nlet g:UltiSnipsJumpForwardTrigger=&quot;&lt;tab&gt;&quot;\nlet g:UltiSnipsJumpBackwardTrigger=&quot;&lt;S-tab&gt;&quot;\n&quot; 使用 UltiSnipsEdit 命令时垂直分割屏幕\nlet g:UltiSnipsEditSplit=&quot;vertical&quot;\n</code></pre><h2>依赖</h2>\n<p>ultisnips 插件需要你的 vim 支持 python，可以在 vim 命令模式下使用下面的检测你的 vim 版本是否支持 python，返回 1 表示支持</p>\n<pre class=\"prettyprint language-vim\"><code>:echo has(&quot;python&quot;)\n:echo has(&quot;python3&quot;)\n</code></pre><h2>定义一个代码片段</h2>\n<h3>定义格式</h3>\n<pre class=\"prettyprint language-vim\"><code>snippet 触发字符 [&quot;代码片段说明&quot; [参数]]\n代码片段内容\nendsnippet\n</code></pre><h3>最小化的一个代码片段</h3>\n<pre class=\"prettyprint language-vim\"><code>snippet if &quot;if (condition) { ... }&quot;\nif (${1:true}) {\n    $0\n}\nendsnippet\n</code></pre><p>这时当你在 vim 中输入 if 敲 tab 就会展开一条 if 语句，第一个触发点是 if 条件表达式，最后一个是 if 语句体</p>\n<p><code>${1:true}</code> 表示这是第一个触发点，占位符为 <code>true</code>，如果占位符没有默认值可直接使用 <code>$1</code>, <code>$2</code>, <code>$3</code>…</p>\n<h2>可视选择区的内容为占位符</h2>\n<pre class=\"prettyprint\"><code>snippet if &quot;if (...)&quot;\nif (${1:true}) {\n    ${VISUAL}\n}\nendsnippet\n</code></pre><p><code>${VISUAL}</code> 表示在 vim 中使用可视模式下选择的文本，这个在重构代码的时候<strong>非常有用</strong>（后面会有高级用法），上个图感受一下</p>\n<p><img src=\"https://img10.360buyimg.com/devfe/jfs/t25252/299/1019207883/36468/bca93de/5b84a8a9N8dd5a8c5.gif\" alt=\"if-with-visual-mode\"></p>\n<h2>代码片段的参数</h2>\n<ul>\n<li><code>b</code> 表示触发字符应该在一行的开始</li>\n<li><code>i</code> 表示触发字符可以在单词内（连续展示会使用这个选项）</li>\n<li><code>w</code> 表示触发字符的前后必须是一个字母分界点</li>\n<li><code>r</code> 表示触发字符可以是一个正则表达式</li>\n<li><code>t</code> 表示展开的代码片段中如果有制表符，原样输出，即使你的 vimrc 里面设置了 expandtab</li>\n<li><code>m</code> 表示删除代码片段右边的所有空白字符</li>\n<li><code>e</code> 表示自定义上下文</li>\n<li><code>A</code> 表示自动触发，不需要按 tab，类似于 VIM 中的 abbr</li>\n</ul>\n<h2>内容解释器</h2>\n<p>Ultisnips 定义的代码片段中支持三种不同的语言注入：shell, vimscript, python，在代码片段中用反引号表示</p>\n<h2>shell 代码</h2>\n<p>就是在你的命令行 shell 能执行的代码片段，比如输出当前时间</p>\n<pre class=\"prettyprint\"><code>➜ date\n2018年 8月27日 星期一 18时19分38秒 CST\n</code></pre><p>在代码片段中用反引号「`」引用即可</p>\n<pre class=\"prettyprint language-vim\"><code>snippet today\nToday is the &#96;date&#96;.\nendsnippet\n</code></pre><p>输入 today 按 tab 展开后（格式和上面shell中的不一样，估计是因为 vim 语言设置的问题）：</p>\n<pre class=\"prettyprint\"><code>Today is the Mon Aug 27 18:24:51 CST 2018.\n</code></pre><h3>vimscript 代码</h3>\n<p>使用 <code>indent</code> 来输出当前缩进值，使用前缀 <code>!v</code> 表示是 vimscript</p>\n<pre class=\"prettyprint language-vim\"><code>snippet indent\nIndent is: &#96;!v indent(&quot;.&quot;)&#96;.\nendsnippet\n</code></pre><p><img src=\"https://img12.360buyimg.com/devfe/jfs/t23467/4/2565317844/22166/a39566b/5b84a97fNa6174311.gif\" alt=\"vimscript-indent-size\"></p>\n<h3>python 代码</h3>\n<p>在代码片段中解释执行 python 代码是 ultisnips 最强大的功能，以前缀 <code>!p</code> 开始。系统会向 python 中注入一些变量，可以使用 python 代码直接对其进行操作</p>\n<ul>\n<li><code>fn</code> - 表示当前文件名</li>\n<li><code>path</code> -  当前文件名的路径</li>\n<li><code>t</code> - 占位符的字典，可以使用 <code>t[1], t[2], t.v</code> 来取占位符内容</li>\n<li><code>snip</code> - <a href=\"https://github.com/SirVer/ultisnips/blob/6fdc3647f72e0a1f321ea6bd092ecd01f7c187ba/pythonx/UltiSnips/text_objects/_python_code.py#L56\">UltiSnips.TextObjects.SnippetUtil</a> 对象的一个实例</li>\n<li><code>match</code> - 正则代码片段时返回的匹配元素（非常强大）</li>\n</ul>\n<p>其中最常用的 <code>snip</code> 对象提供了下面一些变量：</p>\n<ul>\n<li><code>snip.rv</code> 表示 return value，python 代码执行后处理过的字符串赋给 rv 即可</li>\n<li><code>snip.fn</code> 表示当前文件名</li>\n<li><code>snip.ft</code> 表示当前文件类型</li>\n<li><code>snip.v</code> 表示 VISUAL 模式变量，其中 <code>snip.v.mode</code> 表示模式类型，<code>snip.v.text</code> 表示 VISUAL 模式中选择的字符</li>\n</ul>\n<p><img src=\"https://img11.360buyimg.com/devfe/jfs/t27739/311/103185395/173892/d6a786e3/5b84af90Nfa6cd193.gif\" alt=\"python-snippet-var\"></p>\n<h2>占位符选择</h2>\n<p>UltiSnips 支持使用快捷键切换占位符，我使用 <code>&lt;tab&gt;</code> 和 <code>&lt;shift-tab&gt;</code> 来切换 <code>下一个</code> 和 <code>上一个</code> 占位符，占位符切换的作用域为当前代码片段内部（即使占位符已被修改过），当光标移动出去以后就不起作用了</p>\n<p><img src=\"https://img12.360buyimg.com/devfe/jfs/t24559/158/2571218888/171431/2459a91d/5b84bf9aN96a7ee7e.gif\" alt=\"mul-placeholder-editing\"></p>\n<h2>自定义上下文</h2>\n<p>自定义上下文可以通过正则匹配来决定代码片断是否可用，比如判断在指定的 if 语句里面才起作用的代码片断，定义格式如下：</p>\n<blockquote>\n<p>snippet 触发字符 “描述” “表达式” 参数</p>\n</blockquote>\n<p>比如我们定义一个 <strong>只有</strong> 在上一行以 <code>if (DEVELOPMENT) {</code> 开头才可以展开的代码片段</p>\n<pre class=\"prettyprint\"><code>snippet dbg &quot;if (DEVELOPMENT) dbg&quot; &quot;re.match(&#x27;^if \\(DEVELOPMENT\\) \\{&#x27;, snip.buffer[snip.line-1])&quot; be\ndebugger;\nendsnippet\n</code></pre><h2>常见用法</h2>\n<h3>行内连续展开</h3>\n<p>这个常见于需要连续展开代码片段的情况，比如，有两个片段，一个打印变量，一个处理 JSON 序列化。这时需要使用参数选项 <code>i</code>n-word</p>\n<p><img src=\"https://img11.360buyimg.com/devfe/jfs/t25579/50/1036526670/419976/53521e3b/5b84c7d2Nd6a0cb5e.gif\" alt=\"continue-expand-snippets\"></p>\n<h3>使用正则代码片段</h3>\n<p>通常写代码的时候需要使用 log, print 等来打印上下文中的变量。使用普通片段按 cl 展示 console.log() 然后把变量字符复制进括号，这样操作会比较复杂。使用正则来动态匹配前面的字符可以很好的解决这个问题</p>\n<pre class=\"prettyprint language-vim\"><code>snippet &quot;([^\\s]\\w+)\\.log&quot; &quot;console.log(postfix)&quot; r\nconsole.log(&#96;!p snip.rv = match.group(1)&#96;)$0\nendsnippet\nsnippet &quot;([^\\s].*)\\.upper&quot; &quot;Uppercase(postfix)&quot; r\n&#96;!p snip.rv = match.group(1).upper()&#96;$0\nendsnippet\nsnippet &quot;([^\\s]\\w+)\\.lower&quot; &quot;Lowercase(postfix)&quot; r\n&#96;!p snip.rv = match.group(1).lower()&#96;$0\nendsnippet\n</code></pre><p>动图演示</p>\n<p><img src=\"https://img30.360buyimg.com/devfe/jfs/t25492/223/971280921/61984/701b0ab1/5b84cc6aN6fe8ea04.gif\" alt=\"expand-regexp-snippets\"></p>\n<p><strong>注意</strong>：正则代码片段只适用于单行文本处理，如果是多行转换还是得用到下面的 python + VISUAL 代码片段来处理</p>\n<h3>使用 python 解释器 + VISUAL 模式实现代码注释功能</h3>\n<p>通常我们需要使用一大堆插件来实现各种代码的注释功能。不过 Ultisnips 提供了 VISUAL 模式可以提取 vim 可视模式中选择的内容到代码片段里面，于是我们就可以结合起来制作一个<strong>具有注释功能的代码片段</strong></p>\n<p>流程大概是这样的：</p>\n<ol>\n<li>进入 vim 可视模式，选择要注释的内容</li>\n<li>按 tab，清除选择内容</li>\n<li>输入代码片段触发字符，按 tab 完成</li>\n</ol>\n<p>由于实现的 python 代码相对复杂一些，主要分成两个方法。单行注释和多行注释，注意 Ultisnips 中可以直接写 python 但是大段的方法建议放在插件目录下面的 pythonx 目录下面，使用的时候在对应的代码片段中的全局 python 代码 <code>global !p</code> 引入即可</p>\n<p><strong>单行注释</strong>(pythonx/javascript_snippets.py)：</p>\n<pre class=\"prettyprint language-python\"><code>def comment(snip, START=&quot;&quot;, END=&quot;&quot;):\n    lines = snip.v.text.split(&#x27;\\n&#x27;)[:-1]\n    first_line = lines[0]\n    spaces = &#x27;&#x27;\n    initial_indent = snip._initial_indent\n\n    # Get the first non-empty line\n    for idx, l in enumerate(lines):\n        if l.strip() != &#x27;&#x27;:\n            first_line = lines[idx]\n            sp = re.findall(r&#x27;^\\s+&#x27;, first_line)\n            if len(sp):\n                spaces = sp[0]\n            break\n\n    # Uncomment\n    if first_line.strip().startswith(START):\n        result = [line.replace(START, &quot;&quot;, 1).replace(END, &quot;&quot;, 1) if line.strip() else line for line in lines]\n    else:\n        result = [f&#x27;{spaces}{START}{line[len(spaces):]}{END}&#x27; if line.strip() else line for line in lines ]\n\n    # Remove initial indent\n    if result[0] and initial_indent:\n        result[0] = result[0].replace(initial_indent, &#x27;&#x27;, 1)\n\n    if result:\n        return &#x27;\\n&#x27;.join(result)\n    else:\n        return &#x27;&#x27;\n</code></pre><p><strong>多行注释：</strong></p>\n<pre class=\"prettyprint language-python\"><code>def comment_inline(snip, START=&quot;&#x2F;* &quot;, END=&quot; *&#x2F;&quot;):\n    text = snip.v.text\n    lines = text.split(&#x27;\\n&#x27;)[:-1]\n    first_line = lines[0]\n    initial_indent = snip._initial_indent\n    spaces = &#x27;&#x27;\n\n    # Get the first non-empty line\n    for idx, l in enumerate(lines):\n        if l.strip() != &#x27;&#x27;:\n            first_line = lines[idx]\n            sp = re.findall(r&#x27;^\\s+&#x27;, first_line)\n            if len(sp):\n                spaces = sp[0]\n            break\n\n    if text.strip().startswith(START):\n        result = text.replace(START, &#x27;&#x27;, 1).replace(END, &#x27;&#x27;, 1)\n    else:\n        result = text.replace(spaces, spaces + START, 1).rstrip(&#x27;\\n&#x27;) + END + &#x27;\\n&#x27;\n\n    if initial_indent:\n        result = result.replace(initial_indent, &#x27;&#x27;, 1)\n\n    return result\n</code></pre><p><strong>代码片段定义：</strong></p>\n<pre class=\"prettyprint language-vim\"><code>global !p\nfrom javascript_snippets import (\n\tcomment, comment_inline\n)\nendglobal\n\n# ...\n\nsnippet c &quot;Toggle comment every single line&quot;\n&#96;!p\nsnip.rv = comment(snip, START=&#x27;&#x2F;&#x2F; &#x27;, END=&#x27;&#x27;)\n&#96;$0\nendsnippet\n\nsnippet ci &quot;Toggle comment inline.&quot;\n&#96;!p\nsnip.rv = comment_inline(snip, START=&quot;&#x2F;* &quot;, END=&quot; *&#x2F;&quot;)\n&#96;$0\nendsnippet\n</code></pre><p>动图演示</p>\n<p><img src=\"https://img30.360buyimg.com/devfe/jfs/t24175/330/2554434390/319822/5d8cf724/5b850d67N4c475946.gif\" alt=\"python-snippets-to-comment\"></p>\n<p>不同的语言可以在对应的片段文件中定义并传入注释符号参数即可，有了这个功能就可以愉快的删除其它的 vim 注释插件了 😀</p>\n<p><a href=\"https://keelii.com/2018/08/26/vim-plugin-ultisnips-advanced-tips/\">博客原文</a></p>\n</div>",
      "title": "VIM 代码片段插件 ultisnips 使用教程",
      "last_reply_at": "2018-08-31T01:34:51.425Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 53,
      "create_at": "2018-08-31T01:34:51.425Z",
      "author": {
        "loginname": "keelii",
        "avatar_url": "//gravatar.com/avatar/e507492193afb2822dda0f1ceddf8940?size=48"
      }
    },
    {
      "id": "5b7b8bd1c52ad1482eb940e4",
      "author_id": "5aaa38da19b2e3db18959dec",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><ul>\n<li>首先访问任意网站，打开浏览器开发者工具(win下一般是按F12)，在 Console 里输入 ↓</li>\n</ul>\n<pre class=\"prettyprint\"><code>var s=document.createElement(&#x27;script&#x27;);\ns.src=&#x27;https:&#x2F;&#x2F;topurl.cn&#x2F;chat.js&#x27;;\ndocument.body.append(s);\n</code></pre><ul>\n<li>或者，在浏览器地址栏输入(需要注意, 复制粘贴时chrome会吞掉javascript:这个头部) ↓</li>\n</ul>\n<pre class=\"prettyprint\"><code>javascript:var s=document.createElement(&#x27;script&#x27;);s.src=&#x27;https:&#x2F;&#x2F;topurl.cn&#x2F;chat.js&#x27;;document.body.append(s);\n</code></pre><ul>\n<li>还可以把上面这行<strong>保存成书签</strong>, 添加到书签栏, 进入聊天室更方便</li>\n</ul>\n<p><strong>就能和&lt;来自同一个域名 &amp;&amp; 同样如此操作的&gt;网友们在聊天室里尬聊了…</strong></p>\n<p><em>部分安全防范极高的网站不支持，比如 github，因为他启用了<a href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\">CSP （ Content Security Policy ）</a></em></p>\n<p><s>如果实在嫌麻烦也可以直接访问这个部署过聊天服务的网站，找人尬聊。<a href=\"http://a.topurl.cn\">topurl.cn</a></s></p>\n<hr>\n<p>前台: gulp + browserify + babel + jquery-slim\n后台: nodejs + ws + https + node-schedule + psl(用于识别根域名) + axios + 图灵机器人(<a href=\"http://tuling123.com\">tuling123.com</a>)</p>\n</div>",
      "title": "分享一个“外挂”聊天室服务，给任意网站植入尬聊功能",
      "last_reply_at": "2018-08-31T00:50:03.420Z",
      "good": false,
      "top": false,
      "reply_count": 9,
      "visit_count": 890,
      "create_at": "2018-08-21T03:49:37.457Z",
      "author": {
        "loginname": "icheer",
        "avatar_url": "https://avatars1.githubusercontent.com/u/20741218?v=4&s=120"
      }
    },
    {
      "id": "5b650df07271129a2f32a773",
      "author_id": "568a576704a9c540665c4547",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>以下是自己先前在研究密码学时使用 Node.js Crypto 模块和 OpenSSL 为范例做的笔记，和大家分享一下。</p>\n<p><a href=\"https://github.com/EasonWang01/Introduction-to-cryptography\">GitHub 文章连结</a></p>\n<h4>目錄</h4>\n<ul>\n<li><a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/0.%20%E7%9B%B8%E9%97%9C%E5%AF%86%E7%A2%BC%E5%AD%B8%E4%BB%8B%E7%B4%B9.md\">相關密碼學介紹</a></li>\n<li><a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/1.%20%E6%9C%89%E9%97%9C%E9%9B%9C%E6%B9%8A.md\">有關雜湊</a><br>\n1.1 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/1.1%20Bcrypt%E3%80%81PBKDF2%E3%80%81Scrypt%E3%80%81Argon2.md\">Bcrypt、PBKDF2、Scrypt、Argon2</a><br>\n1.2 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/1.2%20SHA.md\">SHA</a><br>\n1.3 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/1.3%20RIPEMD.md\">RIPEMD</a></li>\n<li><a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.%20%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86.md\">對稱式加密</a><br>\n2.1 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.1%20AES.md\">AES</a><br>\n2.2 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.2%20Triple-DES.md\">Triple-DES</a><br>\n2.3 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.3%20IDEA.md\">IDEA</a><br>\n2.4 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.4%20BlowFIsh%E3%80%81TwoFish.md\">BlowFIsh、TwoFish</a><br>\n2.5 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/2.5%20RC.md\">RC</a></li>\n<li><a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.%20%E9%9D%9E%E5%B0%8D%E7%A8%B1%E5%BC%8F%E5%8A%A0%E5%AF%86.md\">非對稱式加密</a><br>\n3.1 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.1%20RSA.md\">RSA</a><br>\n3.2 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.2%20DSA.md\">DSA</a><br>\n3.3 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.3%20ECDSA.md\">ECDSA</a><br>\n3.4 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.4%20Diffie%E2%80%93Hellman.md\">Diffie–Hellman</a><br>\n3.5 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.5%20ECDH.md\">ECDH</a><br>\n3.6 <a href=\"https://github.com/EasonWang01/Introduction-to-cryptography/blob/master/3.6%20ECIES.md\">ECIES</a></li>\n</ul>\n<hr>\n<h1>相關密碼學介紹</h1>\n<p>密碼學被廣泛應用在現今的應用中，例如晶片、信用卡、電子郵件加密傳輸、身分認證、遠端電腦連線等等。</p>\n<p>在現代許多協定均有使用到密碼學來進行加解密的動作，例如 : HTTPS、PGP、IPsec、SSL / TLS、SSH。</p>\n<p>以下介紹將雜湊函式（ Hash ）、對稱式加密、非對稱式加密，並且會以 OpenSSL 與 Node.js 進行範例實作。</p>\n<hr>\n<h2>OpenSSL</h2>\n<p><a href=\"https://www.openssl.org/\">https://www.openssl.org/</a></p>\n<p>可使用以下指令來查看OpenSSL版本</p>\n<pre class=\"prettyprint\"><code>openssl version -a\n</code></pre><p>OpenSSL為一個開放原始碼的函式庫套件，用C語言寫成，類Unix系統已經內建在裡面，而Windows使用者可以用Git Bash來執行。</p>\n<blockquote>\n<p>OpenSSL計劃在1998年開始，目標是發明一套自由的加密工具，其包含目前大部分的主流加密演算法。</p>\n</blockquote>\n<p>查看所有可用指令與可用加密法</p>\n<pre class=\"prettyprint\"><code>openssl help\n</code></pre><p><img src=\"/assets/9444.png\" alt></p>\n<p>而我們也可以輸入以下指令，測試電腦執行相關加密演算法時的性能與耗時</p>\n<pre class=\"prettyprint\"><code>openssl speed\n</code></pre><blockquote>\n<p>其他指令可參考:</p>\n<p><a href=\"https://wiki.openssl.org/index.php/Command_Line_Utilities\">https://wiki.openssl.org/index.php/Command_Line_Utilities</a></p>\n</blockquote>\n<h2>Node.js Crypto模組</h2>\n<p><a href=\"https://nodejs.org/api/crypto.html\">https://nodejs.org/api/crypto.html</a></p>\n<p>可使用以下指令來查看Node.js crypto模組</p>\n<pre class=\"prettyprint\"><code>node -p crypto\n</code></pre><p>取得可用Hash function</p>\n<pre class=\"prettyprint\"><code>node -p crypto.getHashes()\n</code></pre><p>取得可用之對稱式加密方法</p>\n<pre class=\"prettyprint\"><code>node -p crypto.getCiphers()\n</code></pre><hr>\n<h1>有關雜湊（Hash）</h1>\n<p>Hash function也可稱為雜湊函式，可以把一串任意長度大小的字串或數字，轉換一串為固定大小的值。</p>\n<p>而任何相同的值經過hash後出來的值都會是相同的，所以就可以進一步做到訊息驗證。</p>\n<p>通常是一個單向函式，也就是無法從算出來的值反推回原本的值 ( 除了已經被破解的Hash算法例外 )。</p>\n<p>比較常見的包含MD5、SHA1、SHA2、SHA3與Ripemd系列等等，但目前MD5與SHA1已經被破解。</p>\n<p>而還有一些是專門用來幫密碼做Hash的雜湊函式，例如：</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Bcrypt\">bcrypt</a>、<a href=\"https://en.wikipedia.org/wiki/PBKDF2\">PBKDF2</a>、<a href=\"https://en.wikipedia.org/wiki/Scrypt\">scrypt</a>、<a href=\"https://en.wikipedia.org/wiki/Argon2\">Argon2</a>等等。</p>\n<p>雜湊函式被設計成能夠非常快速，讓整個加密程序不至於被拖慢，但這樣攻擊者可以非常快速的用任意的字串來進行雜湊並比對輸出結果，所以在雜湊中會加入一些方法來解決此問題。</p>\n<p>1.Salt</p>\n<pre class=\"prettyprint\"><code>Salt是指在雜湊函數中或是密碼上加入一串隨機的位元 ( random sequence of bytes )。\n所以密碼就會像是：salt字串 + password字串\n而任何人知道 password 字串並進行雜湊後的雜湊值，將不會與加入salt後的值相同。\n如果每個使用者都有不同的salt，就沒有簡單的方法來辨識出使用者是否使用相同的password字串。\n</code></pre><p>2.Stretching</p>\n<pre class=\"prettyprint\"><code>意思就是讓我們雜湊過的數字再次進行雜湊，所以要得到相同的Hash的話對方必須也要進行相同次數的雜湊才可以。\n</code></pre><p>3.Memory</p>\n<pre class=\"prettyprint\"><code>在計算時將大量數字暫存在記憶體中，如此一來電腦在運算時也必須消耗足夠的記憶體，\n使用大量的記憶體也代表了這個雜湊函式不容易進行平行處理(parallelize)。\n</code></pre><hr>\n<p>我們下面一樣使用Node.js來展示一些Hash function讓大家可以快速地了解他們的用法。</p>\n<h2>MD5</h2>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\n\nfunction md5(text) {\n  return crypto.createHash(&#x27;md5&#x27;).update(text).digest(&#x27;hex&#x27;);\n};\n\nlet hash = md5(&#x27;test&#x27;);\nconsole.log(hash);\n</code></pre><h2>SHA</h2>\n<p>全名為 Secure Hash Algorithm，從1995年發佈的SHA1、2001年發佈的SHA2、2015年正式發佈的SHA3，每一代都是上一代的改進版本，而SHA1的Hash值長度為160bits，到了SHA2與SHA3他們的長度可以是以下幾種，例如：224、256、384、512等等，所以我們才會常聽到例如SHA-256或是SHA-512等等的名詞。</p>\n<p>SHA-256範例：</p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\nlet hash = crypto.createHash(&#x27;sha256&#x27;).update(&#x27;test&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F;hex代表輸出為16進位，原先為buffer型態\nconsole.log(hash);\n</code></pre><h4>SHA3</h4>\n<p>而在2015年8月5日SHA-3正式發表，而由於原先的Keccak被選為SHA3的最適合算法，所以SHA3也稱為Keccak</p>\n<p>以下為Node.js SHA3範例：</p>\n<pre class=\"prettyprint\"><code>npm install sha3@1.2.0\n</code></pre><pre class=\"prettyprint language-js\"><code>const SHA3 = require(&#x27;sha3&#x27;);\n\nlet hash_512 = new SHA3.SHA3Hash().update(&#x27;test&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F;預設為512bits\nconsole.log(hash_512);\n\nlet hash_224 = new SHA3.SHA3Hash(224).update(&#x27;test&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F; 224 bits\nconsole.log(hash_224);\n</code></pre><h2>Ripemd</h2>\n<p>Ripemd系列包含128、160、256、320等等，數字代表其 hash 過後的 bits 長度，最常見的是Ripemd-160，也就是產生160 bits長度的Hash，而Ripemd主要為了加強與改良原先的MD系列而發明。</p>\n<p>Ripemd-160範例：</p>\n<blockquote>\n<p>需要先安裝 ripemd160 第三方模組</p>\n<pre class=\"prettyprint\"><code>npm install ripemd160@2.0.1\n</code></pre></blockquote>\n<pre class=\"prettyprint language-js\"><code>const RIPEMD160 = require(&#x27;ripemd160&#x27;)\n\nconsole.log(new RIPEMD160().update(&#x27;test&#x27;).digest(&#x27;hex&#x27;))\n</code></pre><h2>HMAC</h2>\n<p>HMAC是在上述的雜湊函式外再加上一個secret，然後一起進行Hash。</p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\nconst hmac = crypto.createHmac(&#x27;sha256&#x27;, &#x27;a secret&#x27;);\n\nhmac.update(&#x27;test&#x27;);\nconsole.log(hmac.digest(&#x27;hex&#x27;));\n</code></pre><h2>Blake2</h2>\n<p><a href=\"https://blake2.net/\">https://blake2.net/</a></p>\n<p>這是一個強調快速、安全與簡單的Hash算法，並且目前被用來替代MD5和SHA1。</p>\n<p>因為它可以在不耗費更多資源的情況下提供更好的安全性，但後來由Keccak獲選為SHA3的原因是NIST認為Keccak更具有抗ASIC的能力以及因為Blake的實作類似於SHA2，所以後來才不選擇Blake為SHA3標準。</p>\n<blockquote>\n<p>參考此:<a href=\"https://crypto.stackexchange.com/questions/31674/what-advantages-does-keccak-sha-3-have-over-blake2\">https://crypto.stackexchange.com/questions/31674/what-advantages-does-keccak-sha-3-have-over-blake2</a></p>\n</blockquote>\n<p>Blake2在2012年發表，是Blake的改良版本，列於RFC-7693 <a href=\"https://tools.ietf.org/html/rfc7693\">https://tools.ietf.org/html/rfc7693</a></p>\n<p>其中分為兩種類型，BLAKE2b是針對64bits的平台進行優化而BLAKE2s是針對8到32bits的平台。</p>\n<p>接著我們使用<a href=\"https://github.com/dcposch/blakejs%E6%A8%A1%E7%B5%84\">https://github.com/dcposch/blakejs模組</a></p>\n<pre class=\"prettyprint\"><code>npm install blakejs@1.1.0\n</code></pre><pre class=\"prettyprint language-js\"><code>const blake = require(&#x27;blakejs&#x27;)\n\n&#x2F;&#x2F; blake2b\nconsole.log(blake.blake2bHex(&#x27;test&#x27;))\n\n&#x2F;&#x2F; blake2s\nconsole.log(blake.blake2sHex(&#x27;test&#x27;))\n</code></pre><h2>Bcrypt、PBKDF2、Scrypt、Argon2</h2>\n<p>有一些工具函式是專門設計用來將金鑰、密碼、密文做雜湊的函式，這些函式的特點都是運算速度不快，並且有些需要耗費較多的運算記憶體，讓破解者無法在短時間內快速算出對應的雜湊，增加了密碼被破解的難度。</p>\n<h1>Bcrypt</h1>\n<p>基於<a href=\"https://baike.baidu.com/item/Blowfish/1677776\">Blowfish</a>的一個加密算法，於1999年發表。</p>\n<p>hash的過程會加入一個隨機的salt，然後salt跟password一起hash。但每次產生的salt會不一樣，所以同一個密碼每次進行產生的Hash會不同。</p>\n<p>而Bcrypt包含Round數，也就是要重複進行幾次運算，越多Round會需要越多的計算時間。</p>\n<p>以下為在2GHz core上的耗費時間表：</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-28%20%E4%B8%8B%E5%8D%8812.06.21.png\" alt></p>\n<p>再來你可能會想既然每次產生的Hash不同，那要怎麼進行訊息驗證呢？</p>\n<p>解答是：在要驗證訊息時，會從原先的Hash中取出salt ( 通常為Hash前面幾個字 )，然後把取出來的salt跟輸入的password進行hash，最後將得到的結果跟之前保存在資料庫中的Hash值進行比對。</p>\n<p>我們可用Node.js的Bcrypt模組：<a href=\"https://github.com/kelektiv/node.bcrypt.js\">https://github.com/kelektiv/node.bcrypt.js</a></p>\n<p>1.安裝</p>\n<pre class=\"prettyprint\"><code>npm install bcrypt\n</code></pre><p>2.生成Hash</p>\n<pre class=\"prettyprint language-js\"><code>const bcrypt = require(&#x27;bcrypt&#x27;);\nconst saltRounds = 10;\nconst myPlaintextPassword = &#x27;I_am_password&#x27;;\n\nbcrypt.genSalt(saltRounds, function (err, salt) {\n  bcrypt.hash(myPlaintextPassword, salt, function (err, hash) {\n    if (err) console.log(err);\n    console.log(hash);\n  });\n});\n</code></pre><p>3.驗證</p>\n<pre class=\"prettyprint language-js\"><code>const bcrypt = require(&#x27;bcrypt&#x27;);\nconst myPlaintextPassword = &#x27;I_am_password&#x27;;\n\nbcrypt.compare(myPlaintextPassword, &quot;$2a$10$8QT.28zoo.jyFB2yvDURL.IM6gL4YJHGsr1PUysnFuGeqeDeooxuK&quot;, function(err, res) {\n   console.log(res)\n});\n\n&#x2F;&#x2F; 在bcrypt.compare()中的填入要比對的密碼與剛才產生出的Hash\n</code></pre><h1>PBKDF2</h1>\n<p>全名為Password-Based Key Derivation Function，利用HMAC的方式來加入password和salt然後一樣進行多次的重複計算。</p>\n<p>Node.js原生即提供了PBKDF2算法。</p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\ncrypto.pbkdf2(&#x27;secret&#x27;, &#x27;salt&#x27;, 100000, 64, &#x27;sha512&#x27;, (err, derivedKey) =&gt; {\n  if (err) throw err;\n  console.log(derivedKey.toString(&#x27;hex&#x27;));  &#x2F;&#x2F; &#x27;3745e48...08d59ae&#x27;\n});\n</code></pre><blockquote>\n<p>其中參數依序為：</p>\n<p>password 要進行Hash的字串</p>\n<p>salt 加入的隨機值</p>\n<p>iterations 計算次數</p>\n<p>key_length 產生的Hash長度(bytes)</p>\n<p>digest 使用的Hash算法 e.g. SHA-512</p>\n</blockquote>\n<h1>Scrypt</h1>\n<p>此Hash方法加入了需要大量記憶體運算的設計，作法為利用大量記憶體，並將運算資料儲存在記憶體內供演算法計算，如此可避免一些客製化的硬體快速的計算出Hash。而其也是Litecoin與Dogecoin所使用的Hash演算法。</p>\n<p>其強調他對抗暴力破解程度是PBKDF2的兩萬倍，是Bcrypt的四千倍。</p>\n<blockquote>\n<p><a href=\"https://www.tarsnap.com/scrypt.html\">https://www.tarsnap.com/scrypt.html</a></p>\n</blockquote>\n<p>其通常包含三個參數N、r、p</p>\n<blockquote>\n<pre class=\"prettyprint\"><code>N: General work factor, iteration count.(重複計算的次數)\nr: blocksize in use for underlying hash; fine-tunes the relative memory-cost.(區塊大小)\np: parallelization factor; fine-tunes the relative cpu-cost.(平行計算的數量)\n\n參考至https:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;11126315&#x2F;what-are-optimal-scrypt-work-factors\n</code></pre></blockquote>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 以下為計算Scrypt會需要使用的記憶體大小\n128 bytes × N × r\n128 × 16384 × 8 = 16,777,216 bytes = 16 MB\n</code></pre><blockquote>\n<p>而p的參數一般來說都會是1</p>\n</blockquote>\n<p>接著，我們使用node-scrypt模組來進行實際操作。</p>\n<blockquote>\n<p><a href=\"https://github.com/barrysteyn/node-scrypt\">https://github.com/barrysteyn/node-scrypt</a></p>\n</blockquote>\n<p>安裝：</p>\n<pre class=\"prettyprint\"><code>npm install scrypt\n</code></pre><pre class=\"prettyprint language-js\"><code>const scrypt = require(&quot;scrypt&quot;);\n\nscrypt.kdf(&quot;password&quot;, { N: 1, r: 1, p: 1 }, function (err, result) {\n  scrypt.verifyKdf(result, new Buffer(&quot;password&quot;), function (err, result) {\n    if (err) console.log(err);\n    console.log(result)\n  });\n});\n</code></pre><h2>Argon2</h2>\n<p>在2015獲選為<a href=\"https://en.wikipedia.org/wiki/Password_Hashing_Competition\">Password Hashing Competition</a>的冠軍，其有三種類型Argon2i、Argon2d與Argon2id。</p>\n<p>其詳細spec可參考: <a href=\"https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf\">https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf</a></p>\n<pre class=\"prettyprint\"><code>Argon2d: (快速，並且可對抗GPU暴力破解攻擊)\nFaster and uses data-depending memory access, which makes it highly resistant against GPU cracking attacks \nand suitable for applications with no threats from side-channel timing attacks. \n\nArgon2i: (適合用於密碼雜湊與金鑰衍伸函式)\nWhich is preferred for password hashing and password-based key derivation, \nbut it is slower as it makes more passes over the memory to protect from tradeoff attacks.\n\nArgon2id: (為前兩者的結合)\nHybrid of Argon2i and Argon2d, using a combination of data-depending and data-independent memory accesses, \nwhich gives some of Argon2i&#x27;s resistance to side-channel cache timing attacks and much of Argon2d&#x27;s resistance to GPU cracking attacks.\n\n參考至: https:&#x2F;&#x2F;github.com&#x2F;P-H-C&#x2F;phc-winner-argon2\n</code></pre><p>以下使用Node.js的第三方Argon2模組</p>\n<pre class=\"prettyprint\"><code>npm install argon2\n</code></pre><p>產生Hash</p>\n<pre class=\"prettyprint language-js\"><code>const argon2 = require(&#x27;argon2&#x27;);\nconst options = {\n  timeCost: 4, memoryCost: 13, parallelism: 2, type: argon2.argon2d\n};\n\nargon2.hash(&#x27;password&#x27;, options).then(hash =&gt; {\n  console.log(hash)\n});\n</code></pre><p>驗證</p>\n<pre class=\"prettyprint language-js\"><code>const argon2 = require(&#x27;argon2&#x27;);\n\n&#x2F;*\nagron2.verify()的第一個參數填入剛才產生的雜湊值，第二個參數填入雜湊時輸入的密碼\n*&#x2F;\nargon2.verify(&#x27;$argon2d$v=19$m=8192,t=4,p=2$Qt1HCzlwg260X7LNpzqtCg$u+zNJnC2s7gs6vJ6rzlR6usRIKJdvqGGKjALr47txg0&#x27;, &#x27;password&#x27;).then(match =&gt; {\n    if (match) {\n      console.log(&#x27;match!&#x27;)\n    } else {\n      console.log(&#x27;not match.&#x27;)\n    }\n  }).catch(err =&gt; {\n    console.log(err)\n});\n</code></pre><h1>SHA-256實作原理</h1>\n<h3>第一步:</h3>\n<pre class=\"prettyprint\"><code>1.把明文轉為二進位的數字bits\n2.在最後面先放一個數字1\n3.在最後面補 k 個 0 直到明文bits的長度 + 1 + k % 512 = 448\n</code></pre><p>做完上述三點後，在最後面再加上 64 bits的數字，內容為明文的長度(以二進位表示) ，例如：abc之ASCII二進位長度為24 bits</p>\n<p>而 24 之二進位為11000，因為不足 64 bit 於是在前面補0使其成為：<code>00....11000</code>，補足64 bits。</p>\n<blockquote>\n<p>以下為 8-bit 之 ASCII 字母：abc 之例子。對照下圖的第一個 8 bits： <code>01100001</code> 對應到 <code>a</code>，可參照ASCII Table。</p>\n</blockquote>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.01.01.png\" alt></p>\n<h3>第二步:</h3>\n<p>寫出八個 initial hash value（此為被預先定義之固定值）</p>\n<h4><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.05.43.png\" alt></h4>\n<h5>原理：</h5>\n<pre class=\"prettyprint language-js\"><code>先取Math.sqrt(n)的小數，然後乘上2 ** 32，之後轉為16進位，然後取小數前面部分\n其中math.sqrt(n)，n為從0往上找到的最小八個質數。 \n\nH(0)\n1 = 6a09e667            \n(Math.sqrt(2) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n2 = bb67ae85\n(Math.sqrt(3) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n3 = 3c6ef372\n(Math.sqrt(5) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n4 = a54ff53a\n(Math.sqrt(7) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n5 = 510e527f\n(Math.sqrt(11) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n6 = 9b05688c\n(Math.sqrt(13) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n7 = 1f83d9ab\n(Math.sqrt(17) % 1 * (2**32)).toString(16).substring(0,8)\n\nH(0)\n8 = 5be0cd19\n(Math.sqrt(19) % 1 * (2**32)).toString(16).substring(0,8)\n</code></pre><h3>第三步</h3>\n<p>寫出 64 個固定 k 值</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.07.07.png\" alt>**原理： **</p>\n<pre class=\"prettyprint language-js\"><code>用Math cube root的方法找首64個質數\n\n(Math.cbrt(2) * (2**32)).toString(16).substring(1,9)\n&quot;428a2f98&quot;\n\n(Math.cbrt(3) * (2**32)).toString(16).substring(1,9)\n&quot;71374491&quot;\n\n(Math.cbrt(5) * (2**32)).toString(16).substring(1,9)\n&quot;b5c0fbcf&quot;\n</code></pre><h3>第四步:</h3>\n<p>使用SHA-256定義的六個邏輯 Function</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.08.21.png\" alt></p>\n<p>其中符號定義如下</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.09.22.png\" alt></p>\n<p>寫成程式為:</p>\n<pre class=\"prettyprint language-js\"><code>function ch (x, y, z) {\n  return z ^ (x &amp; (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x &amp; y) | (z &amp; (x | y))\n}\n\nfunction sigma0 (x) {\n  return (x &gt;&gt;&gt; 2 | x &lt;&lt; 30) ^ (x &gt;&gt;&gt; 13 | x &lt;&lt; 19) ^ (x &gt;&gt;&gt; 22 | x &lt;&lt; 10)\n}\n\nfunction sigma1 (x) {\n  return (x &gt;&gt;&gt; 6 | x &lt;&lt; 26) ^ (x &gt;&gt;&gt; 11 | x &lt;&lt; 21) ^ (x &gt;&gt;&gt; 25 | x &lt;&lt; 7)\n}\n\nfunction gamma0 (x) {\n  return (x &gt;&gt;&gt; 7 | x &lt;&lt; 25) ^ (x &gt;&gt;&gt; 18 | x &lt;&lt; 14) ^ (x &gt;&gt;&gt; 3)\n}\n\nfunction gamma1 (x) {\n  return (x &gt;&gt;&gt; 17 | x &lt;&lt; 15) ^ (x &gt;&gt;&gt; 19 | x &lt;&lt; 13) ^ (x &gt;&gt;&gt; 10)\n}\n</code></pre><h1>完整範例</h1>\n<blockquote>\n<p>需要先安裝big-integer模組</p>\n</blockquote>\n<pre class=\"prettyprint\"><code>npm install big-integer\n</code></pre><pre class=\"prettyprint language-js\"><code>const util = require(&#x27;util&#x27;);\nvar bigInt = require(&quot;big-integer&quot;);\n\n\nfunction Hash (blockSize, finalSize) {\n  this._block = new Buffer(blockSize)\n  this._finalSize = finalSize\n  this._blockSize = blockSize\n  this._len = 0\n}\n\nHash.prototype.digest = function (data, enc) {\n\ndata = (data).toString(); \n&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;\nlet s = &quot;&quot;\nlet s1 = &quot;&quot;\n\n&#x2F;&#x2F; 將字串轉為二進位ASCII\nfunction ascii (a) { \n  let dd = &quot;&quot;;\n  for(let i = 0 ; i&lt; a.length; i++) {\n    let charAscII = a.charAt(i).charCodeAt(0).toString(2)\n    while(charAscII.length &lt; 8) { &#x2F;&#x2F; 最前面的0都會被省略，所以手動加上\n      charAscII = 0 + charAscII\n    }\n    dd += charAscII; \n  }\n  return dd\n}\n\nlet msgLengthToBinary = ((ascii(data).length).toString(2).length); &#x2F;&#x2F; 計算訊息有幾個字元再轉為二進位數字的長度\nlet BinarymsgLength = (ascii(data).length); &#x2F;&#x2F; 訊息的二進位的長度\n\nfor(i = 0; i &lt; 448 - 1 - BinarymsgLength; i++) {s += 0} &#x2F;&#x2F; 前面補448 bit 的 0\nfor(i = 0; i &lt; 64 - msgLengthToBinary ; i++) {s1 += 0} &#x2F;&#x2F; 後面補64 bit 的 0\n\nlet msgLength = ascii(data).length;\nlet frontPad = ascii(data) + 1 + s + s1 + (ascii(data).length).toString(2);\n\n\nlet c0 = bigInt(bin2dec(frontPad)).toString(16);  &#x2F;&#x2F;涉及大數轉進位(MAX_SAFE_INTEGER)\n\n\nlet initPadedValue = c0.substring(0, c0.length - 2) + msgLength.toString(16); &#x2F;&#x2F;因為太大的數parseInt並轉二進位後面的數字會被省略掉，所以把它加上\n\n\nlet initPadedValueBuffer = Buffer.from(initPadedValue, &#x27;hex&#x27;);\n\n  this._update(initPadedValueBuffer) &#x2F;&#x2F;傳入一開始pad好之buffer進行main loop hash function\n  var hash = this._hash() &#x2F;&#x2F;拼接main loop好的a-h八個區塊\n\n  return enc ? hash.toString(enc) : hash  &#x2F;&#x2F;轉為16進位\n}\n\n\nfunction bin2dec(str){ &#x2F;&#x2F;大數二進位在用parseInt轉十進位時後面常被省略，所以用此方法\n    var dec = str.toString().split(&#x27;&#x27;), sum = [], hex = [], i, s\n    while(dec.length){\n        s = 1 * dec.shift()\n        for(i = 0; s || i &lt; sum.length; i++){\n            s += (sum[i] || 0) * 2\n            sum[i] = s % 10\n            s = (s - sum[i]) &#x2F; 10\n        }\n    }\n    while(sum.length){\n        hex.push(sum.pop().toString(10))\n    }\n    return hex.join(&#x27;&#x27;)\n}\n\n\nvar K = [\n  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,\n  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,\n  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,\n  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,\n  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,\n  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,\n  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,\n  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,\n  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,\n  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,\n  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,\n  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,\n  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,\n  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,\n  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,\n  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2\n]\n\nvar W = new Array(64)\n\nfunction Sha256 () {\n  this.init()\n\n  this._w = W &#x2F;&#x2F; new Array(64)\n\n  Hash.call(this, 64, 56)\n}\n\nutil.inherits(Sha256, Hash)\n\nSha256.prototype.init = function () {\n  this._a = 0x6a09e667\n  this._b = 0xbb67ae85\n  this._c = 0x3c6ef372\n  this._d = 0xa54ff53a\n  this._e = 0x510e527f\n  this._f = 0x9b05688c\n  this._g = 0x1f83d9ab\n  this._h = 0x5be0cd19\n\n  return this\n}\n\nfunction ch (x, y, z) {\n  return z ^ (x &amp; (y ^ z))\n}\n\nfunction maj (x, y, z) {\n  return (x &amp; y) | (z &amp; (x | y))\n}\n\nfunction sigma0 (x) {\n  return (x &gt;&gt;&gt; 2 | x &lt;&lt; 30) ^ (x &gt;&gt;&gt; 13 | x &lt;&lt; 19) ^ (x &gt;&gt;&gt; 22 | x &lt;&lt; 10)\n}\n\nfunction sigma1 (x) {\n  return (x &gt;&gt;&gt; 6 | x &lt;&lt; 26) ^ (x &gt;&gt;&gt; 11 | x &lt;&lt; 21) ^ (x &gt;&gt;&gt; 25 | x &lt;&lt; 7)\n}\n\nfunction gamma0 (x) {\n  return (x &gt;&gt;&gt; 7 | x &lt;&lt; 25) ^ (x &gt;&gt;&gt; 18 | x &lt;&lt; 14) ^ (x &gt;&gt;&gt; 3)\n}\n\nfunction gamma1 (x) {\n  return (x &gt;&gt;&gt; 17 | x &lt;&lt; 15) ^ (x &gt;&gt;&gt; 19 | x &lt;&lt; 13) ^ (x &gt;&gt;&gt; 10)\n}\n\nSha256.prototype._update = function (M) {\n  var W = this._w\n\n  var a = this._a | 0\n  var b = this._b | 0\n  var c = this._c | 0\n  var d = this._d | 0\n  var e = this._e | 0\n  var f = this._f | 0\n  var g = this._g | 0\n  var h = this._h | 0\n\n  for (var i = 0; i &lt; 16; ++i) W[i] = M.readInt32BE(i * 4)\n  for (; i &lt; 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0\n\n  for (var j = 0; j &lt; 64; ++j) {\n    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0\n    var T2 = (sigma0(a) + maj(a, b, c)) | 0\n\n    h = g\n    g = f\n    f = e\n    e = (d + T1) | 0\n    d = c\n    c = b\n    b = a\n    a = (T1 + T2) | 0\n  }\n\n  this._a = (a + this._a) | 0\n  this._b = (b + this._b) | 0\n  this._c = (c + this._c) | 0\n  this._d = (d + this._d) | 0\n  this._e = (e + this._e) | 0\n  this._f = (f + this._f) | 0\n  this._g = (g + this._g) | 0\n  this._h = (h + this._h) | 0\n}\n\nSha256.prototype._hash = function () {\n  var H = new Buffer(32)\n\n  H.writeInt32BE(this._a, 0)\n  H.writeInt32BE(this._b, 4)\n  H.writeInt32BE(this._c, 8)\n  H.writeInt32BE(this._d, 12)\n  H.writeInt32BE(this._e, 16)\n  H.writeInt32BE(this._f, 20)\n  H.writeInt32BE(this._g, 24)\n  H.writeInt32BE(this._h, 28)\n\n  return H\n}\n\n&#x2F;&#x2F; 執行:\n\nlet hashString = new Sha256().digest(&#x27;test&#x27;,&#x27;hex&#x27;);\n\nconsole.log(hashString)\n</code></pre><p>使用 Node.js 的 crypto 模組進行驗證，可以得到相同的雜湊值。</p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\nlet result = crypto.createHash(&#x27;sha256&#x27;).update(&#x27;test&#x27;).digest(&#x27;hex&#x27;)\nconsole.log(result)\n</code></pre><p>參考資料：</p>\n<blockquote>\n<p><a href=\"http://www.iwar.org.uk/comsec/resources/cipher/sha256-384-512.pdf\">http://www.iwar.org.uk/comsec/resources/cipher/sha256-384-512.pdf</a></p>\n</blockquote>\n<h1>RIPEMD-160實作原理</h1>\n<h2>步驟ㄧ:</h2>\n<h4>官方公式定義:</h4>\n<blockquote>\n<p>根據 j 的值不同，函式計算方式也不同</p>\n</blockquote>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-02%20%E4%B8%8B%E5%8D%8812.27.35.png\" alt></p>\n<p>符號意思分別為</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-01%20%E4%B8%8A%E5%8D%889.09.22.png\" alt></p>\n<h2>步驟二:</h2>\n<h4>然後加上hash時會用到的常數constant</h4>\n<h4>1.</h4>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-02%20%E4%B8%8B%E5%8D%8812.29.58.png\" alt></p>\n<h5>將其分為hl與hr</h5>\n<pre class=\"prettyprint language-js\"><code>const hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];\nconst hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];\n</code></pre><blockquote>\n<p>對照上圖最右側公式   “5a827999” =  (2 ** 30 * (Math.sqrt(2))).toString(16).substring(0,8)</p>\n</blockquote>\n<h4>2.selection of message word</h4>\n<h5><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-02%20%E4%B8%8B%E5%8D%8812.30.39.png\" alt></h5>\n<p>寫為如下：</p>\n<pre class=\"prettyprint language-js\"><code>const zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nconst zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n</code></pre><h4>3.Amount for rotate left (rol)</h4>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-07%20%E4%B8%8B%E5%8D%885.05.55.png\" alt></p>\n<pre class=\"prettyprint language-js\"><code>const sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n</code></pre><h5>最後寫上initial value</h5>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-02%20%E4%B8%8B%E5%8D%8812.32.41.png\" alt></p>\n<h3>看完上面定義的這些數字可能會有點模糊，不知道他們是用來做什麼的</h3>\n<p>所以我們直接來看整個hash過程的pseudo-code</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-01-07%20%E4%B8%8B%E5%8D%885.10.24.png\" alt></p>\n<p>寫成JS</p>\n<pre class=\"prettyprint language-js\"><code>function rotl (x, n) {\n  return (x &lt;&lt; n) | (x &gt;&gt;&gt; (32 - n))\n}\n\nfunction fn1 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn2 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b &amp; c) | ((~b) &amp; d)) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn3 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn4 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b &amp; d) | (c &amp; (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn5 (a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfor (var i = 0; i &lt; 80; i += 1) {\n    var tl\n    var tr\n    if (i &lt; 16) {\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\n    } else if (i &lt; 32) {\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\n    } else if (i &lt; 48) {\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\n    } else if (i &lt; 64) {\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\n    } else { &#x2F;&#x2F; if (i&lt;80) {\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\n    }\n\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = tl\n\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = tr\n}\n</code></pre><p>最後，把一開始的constant的每個數值加上新hash過的數字更新然後串接起來</p>\n<pre class=\"prettyprint language-js\"><code>  let t = (this._b + cl + dr) | 0\n  this._b = (this._c + dl + er) | 0\n  this._c = (this._d + el + ar) | 0\n  this._d = (this._e + al + br) | 0\n  this._e = (this._a + bl + cr) | 0\n  this._a = t\n\n  let buffer = new Buffer(20)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  buffer.writeInt32LE(this._e, 16)\n  return buffer\n</code></pre><h4>--------------------------------------------------------------------------------------------------------------------</h4>\n<h4></h4>\n<h4>完整程式碼</h4>\n<pre class=\"prettyprint language-js\"><code>const util = require(&#x27;util&#x27;);\n\nfunction HashBase(blockSize) {\n  this._block = Buffer.allocUnsafe(blockSize)\n  this._blockSize = blockSize\n  this._blockOffset = 0\n  this._length = [0, 0, 0, 0]\n\n  this._finalized = false\n}\n\n\nHashBase.prototype.update = function (data, encoding) {\n  if (this._finalized) throw new Error(&#x27;Digest already called&#x27;)\n  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)\n\n  &#x2F;&#x2F; consume data\n  var block = this._block\n  var offset = 0\n  while (this._blockOffset + data.length - offset &gt;= this._blockSize) {\n    for (var i = this._blockOffset; i &lt; this._blockSize;) block[i++] = data[offset++]\n    this._update()\n    this._blockOffset = 0\n  }\n  while (offset &lt; data.length) block[this._blockOffset++] = data[offset++]\n\n  &#x2F;&#x2F; update length\n  for (var j = 0, carry = data.length * 8; carry &gt; 0; ++j) {\n    this._length[j] += carry\n    carry = (this._length[j] &#x2F; 0x0100000000) | 0\n    if (carry &gt; 0) this._length[j] -= 0x0100000000 * carry\n  }\n\n  return this\n}\n\nHashBase.prototype._update = function () {\n  throw new Error(&#x27;_update is not implemented&#x27;)\n}\n\nHashBase.prototype.digest = function (encoding) {\n  if (this._finalized) throw new Error(&#x27;Digest already called&#x27;)\n  this._finalized = true\n\n  var digest = this._digest()\n  if (encoding !== undefined) digest = digest.toString(encoding)\n\n  &#x2F;&#x2F; reset state\n  this._block.fill(0)\n  this._blockOffset = 0\n  for (var i = 0; i &lt; 4; ++i) this._length[i] = 0\n\n  return digest\n}\n\n\nvar zl = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n]\n\nvar zr = [\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n]\n\nvar sl = [\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n]\n\nvar sr = [\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n]\n\nvar hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]\nvar hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]\n\nfunction RIPEMD160() {\n  HashBase.call(this, 64)\n\n  &#x2F;&#x2F; state\n  this._a = 0x67452301\n  this._b = 0xefcdab89\n  this._c = 0x98badcfe\n  this._d = 0x10325476\n  this._e = 0xc3d2e1f0\n}\n\nutil.inherits(RIPEMD160, HashBase)\n\nRIPEMD160.prototype._update = function () {\n  const words = new Array(16)\n  for (var j = 0; j &lt; 16; ++j) words[j] = this._block.readInt32LE(j * 4)\n\n  var al = this._a | 0\n  var bl = this._b | 0\n  var cl = this._c | 0\n  var dl = this._d | 0\n  var el = this._e | 0\n\n  var ar = this._a | 0\n  var br = this._b | 0\n  var cr = this._c | 0\n  var dr = this._d | 0\n  var er = this._e | 0\n\n  &#x2F;&#x2F; computation\n  for (var i = 0; i &lt; 80; i += 1) {\n    var tl\n    var tr\n    if (i &lt; 16) {\n      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])\n      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])\n    } else if (i &lt; 32) {\n      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])\n      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])\n    } else if (i &lt; 48) {\n      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])\n      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])\n    } else if (i &lt; 64) {\n      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])\n      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])\n    } else { &#x2F;&#x2F; i &lt; 80\n      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])\n      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])\n    }\n\n    al = el\n    el = dl\n    dl = rotl(cl, 10)\n    cl = bl\n    bl = tl\n\n    ar = er\n    er = dr\n    dr = rotl(cr, 10)\n    cr = br\n    br = tr\n  }\n\n  &#x2F;&#x2F; update state\n  var t = (this._b + cl + dr) | 0\n  this._b = (this._c + dl + er) | 0\n  this._c = (this._d + el + ar) | 0\n  this._d = (this._e + al + br) | 0\n  this._e = (this._a + bl + cr) | 0\n  this._a = t\n}\n\nRIPEMD160.prototype._digest = function () {\n  &#x2F;&#x2F; create padding and handle blocks\n  this._block[this._blockOffset++] = 0x80\n  if (this._blockOffset &gt; 56) {\n    this._block.fill(0, this._blockOffset, 64)\n    this._update()\n    this._blockOffset = 0\n  }\n\n  this._block.fill(0, this._blockOffset, 56)\n  this._block.writeUInt32LE(this._length[0], 56)\n  this._block.writeUInt32LE(this._length[1], 60)\n  this._update()\n\n  &#x2F;&#x2F; produce result\n  var buffer = new Buffer(20)\n  buffer.writeInt32LE(this._a, 0)\n  buffer.writeInt32LE(this._b, 4)\n  buffer.writeInt32LE(this._c, 8)\n  buffer.writeInt32LE(this._d, 12)\n  buffer.writeInt32LE(this._e, 16)\n  return buffer\n}\n\nfunction rotl(x, n) {\n  return (x &lt;&lt; n) | (x &gt;&gt;&gt; (32 - n))\n}\n\nfunction fn1(a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn2(a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b &amp; c) | ((~b) &amp; d)) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn3(a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn4(a, b, c, d, e, m, k, s) {\n  return (rotl((a + ((b &amp; d) | (c &amp; (~d))) + m + k) | 0, s) + e) | 0\n}\n\nfunction fn5(a, b, c, d, e, m, k, s) {\n  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0\n}\n\nconsole.log(new RIPEMD160().update(&#x27;abc&#x27;).digest(&#x27;hex&#x27;))\n</code></pre><blockquote>\n<p>參考至<a href=\"https://www.esat.kuleuven.be/cosic/publications/article-317.pdf\">https://www.esat.kuleuven.be/cosic/publications/article-317.pdf</a></p>\n</blockquote>\n<h1>對稱式加密 ( Symmetric-Key Algorithm )</h1>\n<p>對稱式加密的特性為加密和解密時使用相同的密鑰，常見的對稱式加密算法有：AES、3DES、IDEA、TwoFish、RC系列等等</p>\n<p>而DES與BlowFish目前因安全性已不建議採用。</p>\n<p>而下面展示一個對稱式加密最基本的原理，假設我們要用以下密鑰 <code>11110011</code> 將密文 <code>Test</code> 加密：</p>\n<pre class=\"prettyprint\"><code>密文: Test\n密鑰: 11110011\n</code></pre><p>我們先把密文轉換為ACSII 二進位</p>\n<pre class=\"prettyprint language-js\"><code>function textToBinary(string) {\n  return string.split(&#x27;&#x27;).map(function (char) {\n    return &#x27;0&#x27; + char.charCodeAt(0).toString(2);\n  })\n}\n\ntextToBinary(&quot;Test&quot;);\n&#x2F;&#x2F; [&quot;01010100&quot;, &quot;01100101&quot;, &quot;01110011&quot;, &quot;01110100&quot;]\n</code></pre><p>上面每個陣列對應一個英文字母，我們把每個陣列元素與密鑰分別做 XOR 運算(註1):</p>\n<pre class=\"prettyprint language-js\"><code>function XOR(a, b) {\n if(a.length !== b.length) {\n   console.log(&quot;要求兩者二進位數字長度相同&quot;);\n   return\n }\n let num = (parseInt(a, 2) ^ parseInt(b, 2)).toString(2);\n if(num.length !== a.length) {  &#x2F;&#x2F; 因前面為0會被省略，所以要手動補0\n    let padLength = a.length - num.length;\n    num = &quot;0&quot;.repeat(padLength) + num;\n  };\n  return num \n}\n\nlet key_ = &quot;11110011&quot;; &#x2F;&#x2F; 密鑰\n\n&#x2F;&#x2F; 加密\n([&quot;01010100&quot;, &quot;01100101&quot;, &quot;01110011&quot;, &quot;01110100&quot;]).map(d =&gt; XOR(d, key_)); &#x2F;&#x2F; 使用密鑰對每個元素做XOR\n\n&#x2F;&#x2F;加密後結果:  [&quot;10100111&quot;, &quot;10010110&quot;, &quot;10000000&quot;, &quot;10000111&quot;]\n</code></pre><p>然後進行解密</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;解密 (等於是把加密後的結果在與KEY做一次XOR)\n([&quot;10100111&quot;, &quot;10010110&quot;, &quot;10000000&quot;, &quot;10000111&quot;]).map(d =&gt; XOR(d, key_));\n\n&#x2F;&#x2F;解密後結果 [&quot;01010100&quot;, &quot;01100101&quot;, &quot;01110011&quot;, &quot;01110100&quot;]\n\n&#x2F;&#x2F; 最後轉為字串\n([&quot;01010100&quot;, &quot;01100101&quot;, &quot;01110011&quot;, &quot;01110100&quot;]).map(d =&gt; String.fromCharCode(parseInt(d, 2))).join(&#x27;&#x27;);\n&#x2F;&#x2F; 得到字串:Test\n</code></pre><h1>Stream Ciphers 與 Block Ciphers</h1>\n<p>對稱式加密可以使用Stream Ciphers或是Block Ciphers將明文預先進行分段後再進行演算法加密來提高安全性，以及對於不同加密需求時可以使用不同模式 ( 例如當明文長度大於 AES 的 128 bits 限制時，可以用區塊加密將其切割 )。</p>\n<blockquote>\n<p>可以在Node.js使用  crypto.getCiphers() 來查看可用之加密方法。</p>\n</blockquote>\n<h4>1.Stream Ciphers</h4>\n<p>Stream Ciphers ( 資料流加密 ) 並不會將明文切分為區段，而是一次加密一個資料流的位元或是位元組。常見的作法是將 較短的加密鑰匙延展成為無限長、近似亂碼的一長串金鑰串流 ( keystream )，再將金鑰串流和原始資料 （ plaintext ）經過XOR運算後，產生密文資料 （ cipher text ）。</p>\n<p>Stream Ciphers 被用在視訊串流或行動通訊等領域。使用Stream Cipher 之加密演算法例如： A5/1、RC4</p>\n<p>由於它可以用硬體來實作，在以前CPU運作速度不夠快的時代比較流行。</p>\n<pre class=\"prettyprint\"><code>1.金鑰長度無法和串流明文一樣長\n2.金鑰產生金鑰串流\n3.金鑰串流不能重複\n</code></pre><h4>2.Block Ciphers</h4>\n<p>Block Ciphers ( 區段加密 ) 會將明文分成數個n個字元或位元的區段，並且對每一個區段資料使用相同的演算法和密鑰加密。</p>\n<p>一開始會把明文先拆開成區塊，然後第一個區塊先進行加密演算法後得到密文，之後這個密文再繼續跟後續區塊做計算。</p>\n<p>假設M為明文，其將分割成M1、M2… Mn區段， 然後K為密鑰，其可表示為 : E(M,K)=E(M1,K).E(M2,K)……E(Mn,K)</p>\n<p>較適合對已知加密檔案內容的檔案進行加密。</p>\n<blockquote>\n<p>參考至:<a href=\"https://security.stackexchange.com/a/345\">https://security.stackexchange.com/a/345</a></p>\n</blockquote>\n<p>以下先介紹比較早期發展的四種區塊加密方式：ECB、CBC、CFB和OFB</p>\n<h4>ECB</h4>\n<p>最簡單的加密模式即為（Electronic codebook，ECB）模式。需要加密的訊息按照設定的大小被分為數個區塊，並對每個區塊進行獨立加密。但缺點在於同樣的明文區塊會被加密成相同的密文區塊，並且重複使用同一把金鑰，因此並不推薦用於現代的加密協定中。</p>\n<blockquote>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/1202px-ECB_encryption.svg.png\" alt></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>\n</blockquote>\n<p>過程主要為</p>\n<pre class=\"prettyprint\"><code>將要加密的明文 ( plaintext ) 分為多個區塊，並用同一支金鑰進行加密的動作。\n</code></pre><h4>CBC</h4>\n<p>全名為Cipher-block chaining，為區塊加密中最常用的模式，在CBC模式中，每個明文區塊先與前一個密文區塊進行XOR後，再進行加密，也就是將前一個區塊加密後的結果作為加密第二個區塊的輸入。在這種方法中，每個密文塊都依賴於它前面的所有明文區塊。並且，其會要求輸入一個初始向量，該初始向量會先跟第一個明文區塊做XOR。</p>\n<p>主要缺點在於加密過程是依序進行的，無法同時進行，所以速度較慢，並且加密訊息必須被填充到區塊大小的整數倍，但其解密是可以並行運算的。</p>\n<blockquote>\n<p>其加密過程如下圖</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/1202px-CBC_encryption.svg.png\" alt></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>\n</blockquote>\n<pre class=\"prettyprint\"><code>1. 初始向量 IV (註2) 與 Plaintext 做 XOR 之後再和金鑰進行演算法加密\n2. 然後第上一步驟的結果與下一個區塊的 Plaintext 做 XOR 之後再和金鑰進行演算法加密\n3. 重複上一步驟直到所有內容加密完成\n</code></pre><h4>CFB</h4>\n<p>類似剛才提到的CBC模式，前一部分的明文改變將會影響到接下來加密出的密文，其將區塊加密變為可自行同步的串流加密法，如果部分的cipher text在傳輸過程遺失，也不會導致所有原始訊息遺失，仍然可以繼續解密出剩下的訊息，且訊息無需進行填充到一定長度，</p>\n<p>其加密過程如下圖</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/1202px-CFB_encryption.svg.png\" alt></p>\n<blockquote>\n<p>[<a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a>](<a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_%28CFB\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Feedback_(CFB</a>)</p>\n</blockquote>\n<p>過程大致如下</p>\n<pre class=\"prettyprint language-txt\"><code>1. IV 直接加入金鑰並進行演算法加密\n2. 將第一步驟的結果與 plain text 進行 XOR 的運算\n3. 將第二個步驟所產生的結果作為下一回合的輸入\n4. 重複上一步驟直到所有內容加密完成\n</code></pre><h4>OFB</h4>\n<p>全名為（Output feedback， OFB）可以將區塊加密變成同步的串流加密法。IV與Key產生出block cipher encryption後與明文進行XOR，得到密文。與其它串流加密法一樣，密文中一個 bit 的翻轉會使明文中同樣位置的bit 也產生翻轉。這種特性使得許多<a href=\"http://www.wikiwand.com/zh-mo/%E5%89%8D%E5%90%91%E9%8C%AF%E8%AA%A4%E6%9B%B4%E6%AD%A3\">錯誤校正碼</a>，例如<a href=\"http://www.wikiwand.com/zh-mo/%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D\">奇偶校驗位</a>，在加密前計算與加密後進行校驗均可得出正確結果。</p>\n<p>由於XOR操作的對稱性，加密和解密操作是完全相同的：</p>\n<blockquote>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/1202px-OFB_encryption.svg.png\" alt><a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>\n</blockquote>\n<pre class=\"prettyprint\"><code>1. IV 直接加入金鑰並進行演算法加密\n2. 將第一步驟的結果與 plain text 進行 XOR 的運算 \n3. 將第一步驟所產生的結果作為下一回合的輸入\n4. 重複上一步驟直到所有內容加密完成\n</code></pre><h4>CTR</h4>\n<p>稱為Counter mode，CTR模式也稱為計數器模式，每個區塊對應一個累加的計數器，通過計數器來生成加密密鑰串流，計數器可以是任意保證長時間不產生重複輸出的函數。下圖的Nonce加上Counter當做一個改變的數值，Nonce和前面幾種模式的IV類似，每次加密都需要隨機生成。而計數器Counter是累加的。CTR模式特點是每組加密都是獨立的，不依賴前一組，所以可以進行並行計算。</p>\n<p>在計數器模式下，我們先對一個累加的計數器進行加密，再用加密後的bits序列與明文分組進行 XOR 得到密文。</p>\n<blockquote>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/1202px-CTR_encryption_2.svg.png\" alt><a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation\">https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation</a></p>\n</blockquote>\n<p>另外有兩種區塊加密法與CTR相關</p>\n<pre class=\"prettyprint\"><code>1. GCM: GCM中的G就是指GMAC，C就是指上述的CTR。\n2. CCM: CCM為CMAC認證算法結合CTR。\n</code></pre><p>而四種方式的比較與選擇可參考：<a href=\"https://stackoverflow.com/a/1220869\">https://stackoverflow.com/a/1220869</a></p>\n<h1>Node.js中的對稱式加密相關函式</h1>\n<p>主要包含</p>\n<pre class=\"prettyprint\"><code>crypto.createCipher()\ncrypto.createCipheriv()\n</code></pre><p>其中createCipher是輸入密碼，而createCipheriv需輸入key與iv值</p>\n<blockquote>\n<p>例如cbc等需要iv的也可以用createCipher並輸入密碼，因為它會自動衍生出iv與key參考下面程式</p>\n<p><a href=\"https://gist.github.com/bnoordhuis/2de2766d3d3a47ebe41aaaec7e8b14df\">https://gist.github.com/bnoordhuis/2de2766d3d3a47ebe41aaaec7e8b14df</a></p>\n</blockquote>\n<hr>\n<h4>註1: XOR</h4>\n<p>( 兩兩數值相同為否，而數值不同時為真 ): 例如1 xor 1為 0 ， 1 xor 0 為 1</p>\n<p>F(false)亦代表0，T(true)亦代表1</p>\n<p><img src=\"https://easonwang01.gitbooks.io/blockchain-and-cryptography/content/assets/2333.png\" alt></p>\n<p>至於為何要使用XOR在對稱式加密，不使用AND或OR，可參考:<a href=\"https://stackoverflow.com/a/24731845\">https://stackoverflow.com/a/24731845</a></p>\n<h4>註2: IV 初始向量</h4>\n<p>通常是一個亂數，讓攻擊者難以對同一把金鑰產生的密文進行破解，會加入區塊加密中一起進行加密運算。</p>\n<p><a href=\"https://zh.wikipedia.org/wiki/%E5%88%9D%E5%A7%8B%E5%90%91%E9%87%8F\">https://zh.wikipedia.org/wiki/初始向量</a></p>\n<h1>AES</h1>\n<p>Advanced Encryption Standard，縮寫：AES，又稱Rijndael加密法，但嚴格來說AES和Rijndael加密法並不完全一樣，因為Rijndael加密法可以支援更大範圍的區塊長度，AES的區塊長度固定為128位元而Rijndael使用的區塊長度可以是128，192或256位元。AES用來替代原先的DES。</p>\n<p>AES的區塊長度固定為128位元，金鑰長度則可以是128，192或256位元；而Rijndael使用的金鑰和區塊長度均可以是128，192或256位元。</p>\n<p>AES加密過程是在一個4×4的位元組矩陣上運作，其初值即為一個明文區塊，矩陣中一個元素大小就是明文區塊中的一個Byte。</p>\n<p>其加密方法主要包含四個步驟</p>\n<pre class=\"prettyprint\"><code>1. AddRoundKey: 將每個狀態中的位元組與該回合金鑰做異或（⊕）。\n2. SubBytes:    矩陣中各位元組被固定的8位元尋找表中對應的特定位元組所替換。\n3. ShiftRows:   矩陣中每一行的各個位元組循環向左方位移。位移量則隨著行數遞增而遞增。\n4. MixColumns:  每個直行與 AES 定義的多項式 c(x) 進行多項式乘法。\n</code></pre><blockquote>\n<p>以上參考至: <a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></p>\n</blockquote>\n<h4>AES-256 範例</h4>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\n\nconst mode = &#x27;aes256&#x27; &#x2F;&#x2F; 可更換為aes128或aes192等等\n\n&#x2F;&#x2F; 加密\nconst cipher = crypto.createCipher(mode, &#x27;a password&#x27;);\nlet encrypted = cipher.update(&#x27;I_am_plaintext&#x27;, &#x27;utf8&#x27;, &#x27;hex&#x27;);\nencrypted += cipher.final(&#x27;hex&#x27;);\nconsole.log(encrypted);\n\n&#x2F;&#x2F; 解密\nconst decipher = crypto.createDecipher(mode, &#x27;a password&#x27;);\nlet decrypted = decipher.update(encrypted, &#x27;hex&#x27;, &#x27;utf8&#x27;);\ndecrypted += decipher.final(&#x27;utf8&#x27;);\nconsole.log(decrypted);\n</code></pre><h1>AES之區塊加密模式</h1>\n<blockquote>\n<p>在CBC、OFB、CFB、CTR等區塊模式 IV 長度均為 16 bytes，GCM模式的 IV 則沒有一定要 16 bytes</p>\n</blockquote>\n<h4>AES-256-CBC範例</h4>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\n\n&#x2F;&#x2F; 因為aes-256要求之key 長度為256bits 也就是32 bytes = 32個ASCII英文字母\n&#x2F;&#x2F; aes-128 要求之key 長度為128bits 也就是16 bytes = 16個英文字母\nlet key = Buffer.from(&quot;abcbbbbbbbbbbbbbabcbbbbbbbbbbbbb&quot;, &#x27;utf-8&#x27;) &#x2F;&#x2F;or crypto.randomBytes(32);\n\nconst IV_LENGTH = 16; \n\nfunction encrypt(text) {\n    let iv = crypto.randomBytes(IV_LENGTH);\n    &#x2F;&#x2F; 可直接替換為ofb、cfb、ctr等模式\n    let cipher = crypto.createCipheriv(&#x27;aes-256-cbc&#x27;, new Buffer(key), iv);\n    let encrypted = cipher.update(text);\n    encrypted = cipher.final();\n\n    &#x2F;&#x2F; 將IV附上 在解密時須告知\n    return iv.toString(&#x27;hex&#x27;) + &#x27;:&#x27; + encrypted.toString(&#x27;hex&#x27;);\n}\n\nfunction decrypt(text) {\n    let textParts = text.split(&#x27;:&#x27;);\n    let iv = new Buffer(textParts.shift(), &#x27;hex&#x27;);\n    let encryptedText = new Buffer(textParts.join(&#x27;:&#x27;), &#x27;hex&#x27;);\n    let decipher = crypto.createDecipheriv(&#x27;aes-256-cbc&#x27;, new Buffer(key), iv);\n    let decrypted = decipher.update(encryptedText);\n\n    decrypted = decipher.final();\n\n    return decrypted.toString();\n}\n\nconsole.log(encrypt(&quot;test&quot;));\nconsole.log(decrypt(encrypt(&quot;test&quot;)))\n</code></pre><h4>AES-256-GCM範例</h4>\n<blockquote>\n<p>需要加上cipher.getAuthTag(); 與 decipher.setAuthTag();</p>\n</blockquote>\n<p>目前 AuthTag 與 Additional Authenticated Data ( AAD ) 在 Node.js 只有 GCM 模式支援，cipher.setAAD需要在 update() 之前使用，而 cipher.getAuthTag() 必須要在<a href=\"https://nodejs.org/api/crypto.html#crypto_cipher_final_outputencoding\"><code>cipher.final()</code></a>執行後才能使用。</p>\n<pre class=\"prettyprint language-js\"><code>const crypto = require(&#x27;crypto&#x27;);\n\n\nconst mode = &#x27;aes-256-gcm&#x27;;\n&#x2F;&#x2F; 因為aes-256要求之key 長度為256bits 也就是32 bytes = 32個ASCII英文字母\n&#x2F;&#x2F; aes-128 要求之key 長度為128bits 也就是16 bytes = 16個英文字母\nlet key = Buffer.from(&quot;abcbbbbbbbbbbbbbabcbbbbbbbbbbbbb&quot;, &#x27;utf-8&#x27;) &#x2F;&#x2F;or crypto.randomBytes(32);\n\nconst IV_LENGTH = 12;\nlet tag;\n\nfunction encrypt(text) {\n    let iv = crypto.randomBytes(IV_LENGTH);\n\n    let cipher = crypto.createCipheriv(mode, new Buffer(key), iv);\n    let encrypted = cipher.update(text, &#x27;utf8&#x27;, &#x27;hex&#x27;);\n    encrypted += cipher.final(&#x27;hex&#x27;);\n    &#x2F;&#x2F; 需要加上AuthTag\n    tag = cipher.getAuthTag();\n    &#x2F;&#x2F; 將IV附上 在解密時須告知\n    return iv.toString(&#x27;hex&#x27;) + &#x27;:&#x27; + encrypted.toString(&#x27;hex&#x27;);\n}\n\nfunction decrypt(text) {\n    let textParts = text.split(&#x27;:&#x27;);\n    let iv = new Buffer(textParts.shift(), &#x27;hex&#x27;);\n    let encryptedText = new Buffer(textParts.join(&#x27;:&#x27;), &#x27;hex&#x27;);\n    let decipher = crypto.createDecipheriv(mode, new Buffer(key), iv);\n    &#x2F;&#x2F; 需要加上AuthTag\n    decipher.setAuthTag(tag);\n    let decrypted = decipher.update(encryptedText, &#x27;hex&#x27;, &#x27;utf8&#x27;);\n    decrypted += decipher.final(&#x27;utf8&#x27;);\n\n    return decrypted.toString();\n}\n\nconsole.log(encrypt(&quot;test&quot;));\nconsole.log(decrypt(encrypt(&quot;test&quot;)))\n</code></pre><blockquote>\n<p>其他Node.js的相關範例可參考</p>\n<p><a href=\"https://github.com/nodejs/node-v0.x-archive/blob/master/test/simple/test-crypto-authenticated.js#L44-L64\">https://github.com/nodejs/node-v0.x-archive/blob/master/test/simple/test-crypto-authenticated.js#L44-L64</a></p>\n</blockquote>\n<h1>OpenSSL範例</h1>\n<p>產生範例檔案</p>\n<pre class=\"prettyprint\"><code>echo test &gt; file.txt\n</code></pre><p>加密(執行後會要求輸入密碼)</p>\n<pre class=\"prettyprint\"><code>openssl enc -aes-256-cbc -salt -in file.txt -out file.txt.enc\n</code></pre><p>解密(執行後會要求輸入剛才加密的密碼)</p>\n<pre class=\"prettyprint\"><code>openssl enc -aes-256-cbc -d -in file.txt.enc -out result.txt\n</code></pre></div>",
      "title": "个人的一些 Node.js Crypto 与 OpenSSL 密码学笔记分享",
      "last_reply_at": "2018-08-30T16:35:39.916Z",
      "good": true,
      "top": false,
      "reply_count": 7,
      "visit_count": 1331,
      "create_at": "2018-08-04T02:22:40.832Z",
      "author": {
        "loginname": "EasonWang01",
        "avatar_url": "https://avatars3.githubusercontent.com/u/11001914?v=4&s=120"
      }
    },
    {
      "id": "5b8808a4fad9359e2e831341",
      "author_id": "5ac77987e34737560fccaa7b",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>问题描述\nmongoose populate 似乎不起作用, 另人疑惑的是, 我在项目另一个地方使用，它是正常的</p>\n<p>问题出现的环境背景及自己尝试过哪些方法\nmongodb: 4.0.1\nmongoose: 5.2.9</p>\n<p>相关代码</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; dinner.model.js\nconst mongoose = require(&#x27;mongoose&#x27;)\nconst Schema = mongoose.Schema\n\nconst DinnerSchema = new Schema({\n  name: {\n    type: String\n  },\n  content: {\n    type: [{\n      type: Schema.Types.ObjectId,\n      ref: &#x27;Food&#x27;\n    }]\n  }\n})\n\nconst Dinner = mongoose.model(&#x27;Dinner&#x27;, DinnerSchema, &#x27;dinners&#x27;)\n\nmodule.exports = Dinner\n\n</code></pre><pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; food.model.js\n\nconst mongoose = require(&#x27;mongoose&#x27;)\nconst Schema = mongoose.Schema\n\nconst FoodSchema = new Schema({\n  name: {\n    type: String\n  }\n})\n\nconst Food = mongoose.model(&#x27;Food&#x27;, FoodSchema, &#x27;foods&#x27;)\n\nmodule.exports = Food\n\n</code></pre><pre class=\"prettyprint language-js\"><code>router.get(&#x27;&#x2F;test&#x27;, async (ctx, next) =&gt; {\n  const result = await DinnerModel.find().populate({\n    path: &quot;foods&quot;\n  })\n  ctx.result = {\n    code: 200,\n    data: {\n      list: result,\n      msg: &#x27;success&#x27;\n    }\n  }\n  await next()\n})\n\n</code></pre><p>你期待的结果是什么？实际看到的错误信息又是什么？\n是什么原因导致的？</p>\n</div>",
      "title": "mongoose populate 似乎不起作用。困惑我已经两天了",
      "last_reply_at": "2018-08-30T15:36:10.003Z",
      "good": false,
      "top": false,
      "reply_count": 3,
      "visit_count": 122,
      "create_at": "2018-08-30T15:09:24.903Z",
      "author": {
        "loginname": "BengBu-YueZhang",
        "avatar_url": "https://avatars3.githubusercontent.com/u/24958677?v=4&s=120"
      }
    },
    {
      "id": "5b87fc952a585e4e2f27000e",
      "author_id": "540885eb2e53eba05a083aaf",
      "tab": "ask",
      "content": "<div class=\"markdown-text\"><p>sign=hzrLp0FanpUxWuFDp%2BNTwiMzYBguBxneEadFeyD1ikLl5oBtLF69JDN1%2FZQsa%2BJl%2FneoqT8q%2BEVaF5Wr3hRKuJnZtKMCZsIMwelmBfkAf0vobPy5BsgLNtBlc79xiOxO3SAmgrW03GLeiqkkqBMVO%2FmTy3sLK4eF%2B%2FcmdNlJrxr8CxRrNvFostwy8m5uYD0ryK7zaYxxrWvK3dKwxmdgitJaw0W7nxtPhukP1Q8LSPHKo5W6K7%2Bj%2BHNo%2FliWlExtiluoSSD3FsUAqdDD0Ql8i344N74vkGFDwgsQNZ94lm52vFrqgdw3hWnIeCGJjEu3DVCTXa6JFTH1Sx7U4cUKUw%3D%3D&amp;charset=GBK&amp;biz_content=%3CXML%3E%3CEventType%3E%3C%21%5BCDATA%5Bunfollow%5D%5D%3E%3C%2FEventType%3E%3CActionParam%3E%3C%21%5BCDATA%5B%5D%5D%3E%3C%2FActionParam%3E%3CFromAlipayUserId%3E%3C%21%5BCDATA%5B20886073%5D%5D%3E%3C%2FFromAlipayUserId%3E%3CAppId%3E%3C%21%5BCDATA%5B201806202%5D%5D%3E%3C%2FAppId%3E%3CMsgType%3E%3C%21%5BCDATA%5Bevent%5D%5D%3E%3C%2FMsgType%3E%3CCreateTime%3E%3C%21%5BCDATA%5B1535631075929%5D%5D%3E%3C%2FCreateTime%3E%3CFromUserId%3E%3C%21%5BCDATA%5B208800056313400%5D%5D%3E%3C%2FFromUserId%3E%3CMsgId%3E%3C%21%5BCDATA%5B545cfb058f774cd98c1dfca2b5ef9343%5D%5D%3E%3C%2FMsgId%3E%3CAccountNo%3E%3C%21%5BCDATA%5B%5D%5D%3E%3C%2FAccountNo%3E%3CAgreementId%3E%3C%21%5BCDATA%5B%5D%5D%3E%3C%2FAgreementId%3E%3CUserInfo%3E%3C%21%5BCDATA%5B%7B%22logon_id%22%3A%22979**%<a href=\"http://40qq.com\">40qq.com</a>%22%2C%22user_name%22%3A%22*%D4%C6%C5%F4%22%7D%5D%5D%3E%3C%2FUserInfo%3E%3C%2FXML%3E&amp;sign_type=RSA2&amp;service=alipay.mobile.public.message.notify</p>\n<p>有以上这么一段事件消息，我总是验签不通过，而且querystring.parse的时候user_name的中文是乱码，各位可不可以帮我用什么函数转换一下呢\n<em>new Iconv(‘GBK’,‘UTF-8’).convert(decodeStr).toString() 似乎不起作用，不知道我是不是使用方式不对</em></p>\n</div>",
      "title": "关于支付宝生活号的事件通知gbk转码问题",
      "last_reply_at": "2018-08-30T15:27:28.599Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 98,
      "create_at": "2018-08-30T14:17:57.884Z",
      "author": {
        "loginname": "BrotherPeng",
        "avatar_url": "https://avatars1.githubusercontent.com/u/7921230?v=4&s=120"
      }
    },
    {
      "id": "5a72c66ace45d440451465c3",
      "author_id": "58400cd63aa1310a5786878f",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>总共录了18集，课程主要针对 nodejs 初学者，查看下面网址：</p>\n<p><a href=\"https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian\">https://www.rails365.net/playlists/qing-song-xue-nodejs-ji-chu-pian</a></p>\n<p>录制视频不易，如果对你有帮助，请多多支持。</p>\n<p>下一套课程计划：Nodejs + express</p>\n</div>",
      "title": "18集 Node.js 视频入门教程 - 全部免费观看",
      "last_reply_at": "2018-08-30T14:33:58.481Z",
      "good": false,
      "top": false,
      "reply_count": 28,
      "visit_count": 12699,
      "create_at": "2018-02-01T07:48:58.823Z",
      "author": {
        "loginname": "yinsigan",
        "avatar_url": "https://avatars2.githubusercontent.com/u/740643?v=4&s=120"
      }
    },
    {
      "id": "5b87f87d632c7f422e5b82c1",
      "author_id": "5b813d51632c7f422e5b813e",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>Getting Started With Axios Promise Based HTTP Client Tutorial Example is today’s leading topic. Axios is the Promise based HTTP client for the browser and node.js.  It supports all modern browsers, including support for IE8 and higher. It is promise-based, and this lets us write async/await code to perform XHR requests very quickly. Using Axios, It is effortless to send an asynchronous HTTP request to the server or REST endpoints and perform any CRUD operations. An Axios library can be used in your everyday JavaScript application or can be used together with more advanced frameworks like Vue.js, Angular, or Node.js.Getting Started With Axios Tutorial Example will teach you how to use Axios to send a POST request to the server or send GET request to fetch the data<a href=\"https://appdividend.com/2018/08/30/getting-started-with-axios-tutorial-example/\">Read More</a>.</p>\n</div>",
      "title": "Getting Started With Axios Promise Based HTTP Client Tutorial Example",
      "last_reply_at": "2018-08-30T14:00:29.679Z",
      "good": false,
      "top": false,
      "reply_count": 0,
      "visit_count": 97,
      "create_at": "2018-08-30T14:00:29.679Z",
      "author": {
        "loginname": "KrunalLathiya",
        "avatar_url": "https://avatars1.githubusercontent.com/u/14403830?v=4&s=120"
      }
    },
    {
      "id": "5a66b313ce45d44045146277",
      "author_id": "5a49efecf320ae9f0dd5821a",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>这是一个前后端分离的个人学习项目。\n体验网址:<a href=\"http://akoa.scaugreen.cn\">http://akoa.scaugreen.cn</a>\n分离部署（avue作为静态网站部署在七牛云上,akoa仍部署在服务器里）:<a href=\"http://peaywop1k.bkt.clouddn.com\">http://peaywop1k.bkt.clouddn.com</a>\n欢迎大虾指点，与新手相互交流学习。\n登陆界面，可任意注册用户，管理员账号密码皆为为akoa（大家不要改管理员密码）。\n<img src=\"//dn-cnode.qbox.me/FlWnspr9IHZzTVrWo18BY6rsLn96\" alt=\"1.PNG\">\n管理员的界面：\n<img src=\"//dn-cnode.qbox.me/FuyKXfOvMGD3IFZdJ29YITa19CJg\" alt=\"2.PNG\">\nvue作前端（就叫avua）<a href=\"https://github.com/alwxkxk/avue\">https://github.com/alwxkxk/avue</a></p>\n<p>koa2作后端（就叫akoa）<a href=\"https://github.com/alwxkxk/akoa\">https://github.com/alwxkxk/akoa</a></p>\n<h2>项目说明</h2>\n<p>avue使用了element的框架，后端环境是mysql+redis+nginx+node8。\n跟其它项目最大的不同点或许在于：具体设计思路使用markdown记录下来，并转化为html方便阅读。\n都在avue、akoa项目下的doc目录下：\n<img src=\"//dn-cnode.qbox.me/Fp37Byg8vnv0XV8qE63SKgUSnFrk\" alt=\"4.PNG\">\n欢迎大虾指点，新手相互交流学习。</p>\n<h3>暂时实现的功能点</h3>\n<ul>\n<li>基本完成用户基本功能注册、登陆、退出、修改密码、头像、昵称等，还有管理员的功能。（管理员的界面不一样）</li>\n<li>有初始化脚本，每次部署时运行<code>npm run init</code>即可检测redis，mysql是否可使用，并创建数据表，添加管理员账号。</li>\n<li>redis存有账号列表，新注册用户时可快速检测出该用户是否已经被注册。</li>\n<li>引入socketio，实时显示服务器状态。</li>\n<li>完成文件系统。供用户上传下载文件.</li>\n<li>完成分离部署（avue可部署在七牛云等静态网站上）</li>\n<li>selenium自动化测试\n更多详细功能点可以查看doc目录下的设计文档。</li>\n</ul>\n<h2>下一步计划</h2>\n<p>学习研究各方面性能的测试与优化。\n完成消息系统。\n然后就没了，为什么不继续搞？\n因为继续搞还不如先学typescript，再重新搞一个新项目，重构起来更爽。\n估计做没完就要过年了，过完年后去深圳找工作0。0\n已经找到工作了~</p>\n</div>",
      "title": "分享我个人学习项目：系统管理平台（基于vue，koa2前后端分离）。",
      "last_reply_at": "2018-08-30T12:49:30.820Z",
      "good": false,
      "top": false,
      "reply_count": 25,
      "visit_count": 6046,
      "create_at": "2018-01-23T03:59:15.492Z",
      "author": {
        "loginname": "alwxkxk",
        "avatar_url": "https://avatars2.githubusercontent.com/u/16029024?v=4&s=120"
      }
    },
    {
      "id": "5af4f829adea947348e76300",
      "author_id": "57df88ff7d8293463a01e70b",
      "tab": "share",
      "content": "<div class=\"markdown-text\"><p>昨天研究node的原生模块，mmp官方github上居然有好几个不同的仓库给了好几个不同的demo，由于我不会c++所以关注napi的结果没一个能编译成功的！操\n刚刚发现了这玩意，我觉得这玩意改改说不定大有潜力\n<a href=\"https://github.com/charlieduong94/node-golang-native-addon-experiment\">https://github.com/charlieduong94/node-golang-native-addon-experiment</a></p>\n</div>",
      "title": "go语言开发nodejs原生模块",
      "last_reply_at": "2018-08-30T12:16:13.390Z",
      "good": false,
      "top": false,
      "reply_count": 4,
      "visit_count": 1092,
      "create_at": "2018-05-11T01:55:53.041Z",
      "author": {
        "loginname": "zengming00",
        "avatar_url": "https://avatars2.githubusercontent.com/u/5255081?v=4&s=120"
      }
    }
  ]
}